# 13.interface:接口

很多时候，我们需要调用已经部署在链上的已经合约，这时候可以通过接口合约实现部分调用的逻辑，我们只需要写一个与之对应的接口合约，就可以调用了。

在 solidity 语言中，只要某个合约有和接口种相同的函数声明，就可以被此合约所接受。接口就是起到一个桥接的作用；类似手机的接口，只要匹配，可以进行充电，也可以进行听歌。

`interface` 类似于[抽象合约](/source/10.inheritance.html#abstract) ，但它们不能实现任何功能。还有其他限制。 `interface`内的函数被隐式标记为`virtual`

## 1️⃣ 限制

- 无法实现任何功能，没有函数体。
  - 否则报错:`Functions in interfaces must be declared external.`
- 无法继承其他合约。(需要验证，是否可以继承接口，文档内说可以继承其他接口。)
- 无法定义构造函数。
- 无法定义状态变量。
- 不可以声明修改器。
- 无法定义结构（`strct`）（`0.5.0` 版本开始接口里可以支持声明 `enum` 类型）。
- 所有声明的函数必须是 `external` 的，尽管在合约里可以是 public

文档说：将来可能会解除这里的某些限制。

⚠️注意： interface 可以基于别的 interface。比如 `interface IERC20Metadata is IERC20{}`,定义 `IERC20Metadata` 基于 `IERC20` 接口。

## 2️⃣ 定义和使用

接口需要有 interface 关键字，并且内部只需要有函数的声明，不用实现。只要某合约中有和词接口相同的函数声明，就可以被此合约所接受。语法如下

```
interface 接口名{
    函数声明;
}
```

接口基本上仅限于合约 ABI 可以表示的内容，并且 ABI 和接口之间的转换不应该丢失任何信息。

在下面的例子中，定义了 cat 合约以及 dog 合约。他们都有 eat 方法.以此他们都可以被上面的 animalEat 接口所接收。

### 使用例子

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Cat {
    uint256 public age;

    function eat() public returns (string memory) {
        age++;
        return "cat eat fish";
    }

    function sleep1() public pure returns (string memory) {
        return "sleep1";
    }
}

contract Dog {
    uint256 public age;

    function eat() public returns (string memory) {
        age += 2;
        return "dog miss you";
    }

    function sleep2() public pure returns (string memory) {
        return "sleep2";
    }
}

interface AnimalEat {
    function eat() external returns (string memory);
}

contract Animal {
    function test(address _addr) external returns (string memory) {
        AnimalEat general = AnimalEat(_addr);
        return general.eat();
    }
}
```

测试流程:

1. 部署 Cat 合约
2. 部署 Dog 合约
3. 部署 Animal 合约
4. 调用 `Animal.test`,参数是 Cat 合约地址
   1. 返回 `"string: cat eat fish"`
   2. 在 Cat 合约内查看 `age` 返回的数字
5. 调用 `Animal.test`,参数是 Dog 合约地址
   1. 返回 `"string: dog miss you"`
   2. 在 Dog 合约内查看 `age` 返回的数字

在合约 Animal 中，调用函数 test，如果传递的是部署的 Cat 的合约地址，那么我们在调用接口的 eat 方法时，实则调用了 Cat 合约的 eat 方法。 同理，如果传递的是部署的 Dog 的合约地址，那么我们在调用接口的 eat 方法时，实则调用了 dog 合约的 eat 方法。
### 隐式的标记为`virtual`


就像继承其他合约一样，合约可以继承接口。接口中的函数都会隐式的标记为
`virtual` ，意味着他们会被重写并不需要 `override` 关键字。
但是不表示重写（overriding）函数可以再次重写，仅仅当重写的函数标记为
`virtual` 才可以再次重写。

接口可以继承其他的接口，遵循同样继承规则。

```
pragma solidity >=0.6.2 <0.9.0;

interface ParentA {
    function test() external returns (uint256);
}

interface ParentB {
    function test() external returns (uint256);
}

interface SubInterface is ParentA, ParentB {
    // 必须重新定义 test 函数，以表示兼容父合约含义
    function test() external override(ParentA, ParentB) returns (uint256);
}
```


## 3️⃣ 全局属性 `type(I).interfaceId`

返回接口`I` 的 bytes4 类型的接口 ID，接口 ID 参考： EIP-165 定义的， 接口 ID 被定义为 XOR （异或） 接口内所有的函数的函数选择器（除继承的函数。

## 🆗 实战: 标准的 ERC20 接口
### 标准

**问题: 如何判断一个 Token 合约是否为标准的 ERC20 合约？**

- 只要含有 ERC20 接口规定的所有内容，就算标准的 ERC20 合约。
  - 至于方法内的逻辑是如何实现的，是不做判断。

### 标准 ERC20 接口

- 1 个授权
  - `approve`: 授权指定地址可以操作调用者的最大 Token 数量。
- 2 个事件
  - `Transfer`
  - `Approval`
- 2 个交易
  - `transfer`: 从当前调用者地址发送指定数量的 Token 到指定地址。
    - 这是一个写入方法，所以还会抛出一个 `Transfer` 事件。
  - `transferFrom`: 当向另外一个合约地址存款时，对方合约必须调用 transferFrom 才可以把 Token 拿到它自己的合约中。
- 3 个查询
  - `balanceOf`: 查询指定地址的 Token 数量
  - `totalSupply`: 查询当前合约的 Token 总量
  - `allowance`: 查询指定地址对另外一个地址的剩余授权额度


```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface IERC20 {
    // 1个授权
    function approve(address spender, uint256 amount) external returns (bool);

    // 2个事件
    event Transfer(address indexed from, address indexed to, uint256 amount);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 amount
    );

    // 2个交易
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    // 3个查询
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function allowance(address owner, address spender)
        external
        view
        returns (uint256);
}
```

### ERC20 标准合约实现

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface IERC20 {
    // 1个授权
    function approve(address spender, uint256 amount) external returns (bool);

    // 2个事件
    event Transfer(address indexed from, address indexed to, uint256 amount);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 amount
    );

    // 2个交易
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    // 3个查询
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function allowance(address owner, address spender)
        external
        view
        returns (uint256);
}

contract ERC20 is IERC20 {
    // 状态变量
    string public name;
    string public symbol;
    uint8 public immutable decimals;

    address public immutable owner;

    // uint256 public immutable totalSupply; // 不增加总量
    uint256 public totalSupply; // 总价总量
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    // 函数修改器
    modifier onlyOwner() {
        require(msg.sender == owner, "not owner");
        _;
    }

    // 构造函数
    constructor(
        string memory _name,
        string memory _symbol,
        uint8 _decimals,
        uint256 _totalSupply
    ) {
        owner = msg.sender;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balanceOf[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    // 1个授权
    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    // 2个交易
    function transfer(address recipient, uint256 amount)
        external
        returns (bool)
    {
        balanceOf[msg.sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool) {
        // msg.sender 也就是当前调用者，是被批准者
        allowance[sender][msg.sender] -= amount;
        balanceOf[sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    // 1个铸币 - 非必须
    function mint(uint256 amount) external onlyOwner returns (bool) {
        totalSupply += amount;
        balanceOf[msg.sender] += amount;
        emit Transfer(address(0), msg.sender, amount);
        return true;
    }

    // 1个销毁 - 非必须
    function burn(uint256 amount) external returns (bool) {
        totalSupply -= amount;
        balanceOf[msg.sender] -= amount;
        emit Transfer(msg.sender, address(0), amount);
        return true;
    }
}
```

## 🆗 实战: ERC721 合约

### 场景说明

### 合约代码

### 测试合约

## 🆗 实战: ERC1155 合约

## 🆗 实战: ERC3525 合约

### 对比

![](/_static/13/01.jpeg)

![](/_static/13/02.jpeg)

![](/_static/13/03.jpeg)

![](/_static/13/04.jpeg)


## 🆗 实战:荷兰拍卖

### 原理

拍卖 NFT

- 需要拥有 NFT
- 需要在 NFT 合约内对拍卖合约做 `aoorove`;

### 代码

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface IERC721 {
    function transferFrom(
        address _form,
        address _to,
        uint256 _nftId
    ) external;
}

contract DutchAuction {
    uint256 private immutable duration;

    address payable public immutable seller;

    IERC721 public immutable nft;
    uint256 public immutable nftId;

    uint256 public immutable startingPrice;
    uint256 public immutable startAt;
    uint256 public immutable endAt;
    uint256 public immutable discountRate;

    constructor(
        address _nft,
        uint256 _nftId,
        uint256 _startingPrice,
        uint256 _duration,
        uint256 _discountRate
    ) {
        require(
            _startingPrice >= _duration * _discountRate,
            "starting price < discount"
        );
        seller = payable(msg.sender);
        nft = IERC721(_nft); // 需要 IERC721 进行转换
        nftId = _nftId;
        duration = _duration;
        startingPrice = _startingPrice;
        discountRate = _discountRate;

        startAt = block.timestamp;
        endAt = block.timestamp + _duration;
    }

    // 获取价格
    function getPrice() public view returns (uint256) {
        uint256 timeElapsed = block.timestamp - startAt;
        uint256 discount = discountRate * timeElapsed;
        return startingPrice - discount;
    }

    // 购买
    function buy() external payable {
        // 打包时间需要在拍卖截止之前
        require(block.timestamp < endAt, "Auction has ended");

        uint256 price = getPrice();
        require(msg.value >= price, "Insufficient amount");
        nft.transferFrom(seller, msg.sender, nftId);

        // 如果有多余的钱，需要把钱退会购买者账号(提交时间和打包确认时间不一致)
        uint256 refund = msg.value - price;
        if (refund > 0) {
            payable(msg.sender).transfer(refund);
        }
        selfdestruct(seller);
    }
}
```


## 🆗 实战:英式拍卖

### 原理

拍卖 NFT

- 需要拥有 NFT
- 需要在 NFT 合约内对拍卖合约做 `aoorove`;

### 代码

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface IERC721 {
    function transferFrom(
        address _form,
        address _to,
        uint256 _nftId
    ) external;
}

// TODO: 区块注释信息，可以选择在合约完成后删除
contract HelloComrades {
    /*
     * ========================================
     * State Variables
     * ========================================
     */

    address payable public immutable seller;

    IERC721 public immutable nft;
    uint256 public immutable nftId;

    uint32 public endAt; // 结束时间
    bool public started; // 开始时间
    bool public ended; // 结束时间

    uint256 public highestBid; // 最高出价
    address public highestBider; // 最高出价人
    mapping(address => uint256) public bids; // 除了最高出价外的所有出价人

    /*
     * ========================================
     * Events
     * ========================================
     */
    event Start();
    event End(address highestBider, uint256 amount);
    event Bid(address indexed sender, uint256 amount);
    event Withdraw(address indexed sender, uint256 amount);

    /*
     * ========================================
     * Modifier
     * ========================================
     */

    /*
     * ========================================
     * Errors
     * ========================================
     */

    /*
     * ========================================
     * Constructor
     * ========================================
     */
    constructor(
        address _nft,
        uint256 _nftId,
        uint256 _startingPrice
    ) {
        seller = payable(msg.sender);
        nft = IERC721(_nft); // 需要 IERC721 进行转换
        nftId = _nftId;
        highestBid = _startingPrice;
    }

    /*
     * ========================================
     * Functions
     * ========================================
     */
    function start() external {
        require(msg.sender == seller, "Nor seller");
        require(!started, "started");

        started = true;
        endAt = uint32(block.timestamp + 60);
        nft.transferFrom(seller, address(this), nftId);

        emit Start();
    }

    function bid() external payable {
        require(started, "Not started"); //需要时间已经开始
        require(block.timestamp < endAt, "ended"); // 需要时间还没有过期
        require(msg.value > highestBid, "invalid price"); // 需要高于上次出价

        // 把上一次最高出价和出价人写入账本
        if (highestBider != address(0)) {
            bids[highestBider] += highestBid;
        }

        // 更新最高出价/最高出价人
        highestBid = msg.value;
        highestBider = msg.sender;
        emit Bid(msg.sender, msg.value);
    }

    // 取回自己的出价
    function withdraw() external {
        uint256 bal = bids[msg.sender];
        require(bal > 0, "No amount can be refunded");
        bids[msg.sender] = 0; //为了防止漏洞发生，需要先把状态修改
        payable(msg.sender).transfer(bal);
        emit Withdraw(msg.sender, bal);
    }

    // 结束拍卖;不需要做身份确认，因为需要做的事情是固定的，
    // 能不做身份判断就不需要做，可以节省Gas
    function end() external {
        require(started, "Not started"); // 需要已经开始
        require(!ended, "is ended"); // 需要还没有结束
        require(block.timestamp >= endAt, "auction in progress");
        ended = true;

        if (highestBider != address(0)) {
            // 如果有人出价则将 NFT 给最高出价人，最高价格给销售者
            nft.transferFrom(address(this), highestBider, nftId);
            seller.transfer(highestBid);
        } else {
            // 如果没有人出价，则NFT原路返还给销售者
            nft.transferFrom(address(this), seller, nftId);
        }
        emit End(highestBider, highestBid);
    }

    /*
     * ========================================
     * Helper
     * ========================================
     */
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}
```

### 测试流程

- 部署 ERC721 ,NFT 合约地址是 `nftContractAds`
- 给 `address1` min 一个 ID 是 1 的 NFT
- 部署英式拍卖合约 `EnglishAuction`
  - 输入 NFT 合约地址
  - 输入 NFT ID 号
  - 起拍价格:8
- 在 `nftContractAds` 中 approve `EnglishAuction` , ID 为 1 的 NFT
- 使用 `address2` 出价 1,查看是否返回错误 `Not started`
- 查看合约的状态
  - `started`
  - `ended`
  - `getBalance`
  - `seller`
  - `nft`
  - `nftId`
  - `highestBider`
  - `highestBid`
- 使用 `address1` 出价 1, 开始拍卖合约，查看是否返回错误 `invalid price`
- 再次查看合约的状态
- 使用 `address2` 出价 10
- 使用 `address3` 出价 20
- 使用 `address2` 出价 50
- 查询 `address2` 可退换的主币
- 查询 `address3` 可退换的主币
- 结束拍卖
- 使用 `address2` 取回主币
- 使用 `address3` 取回主币


## #️⃣ 问答题

- `interface` 有哪些限制？
  - 无法实现任何功能，没有函数体。
    - 否则报错:`Functions in interfaces must be declared external.`
  - 无法继承其他合约。(需要验证，是否可以继承接口，文档内说可以继承其他接口。)
  - 无法定义构造函数。
  - 无法定义状态变量。
  - 不可以声明修改器。
  - 无法定义结构（`strct`）（`0.5.0` 版本开始接口里可以支持声明 `enum` 类型）。
  - 所有声明的函数必须是 `external` 的，尽管在合约里可以是 public
  - 文档说：将来可能会解除这里的某些限制。
- `interface` 的意义？
  - 我们需要调用已经部署在链上的已经合约，这时候可以通过接口合约实现部分调用的逻辑，我们只需要写一个与之对应的接口合约，就可以调用了。
- `interface` 和 `abstract`(抽象合约)有啥区别？分别用在什么地方？
- `interface` 的常见用法有哪些？
  - 制定标准，比如最成功的 `ERC20` 接口合约
- `ERC20` 标准接口有哪些内容？
  - 1个授权（approve）
  - 2个事件（Transfer/Approval）
  - 2个交易（transfer/transferFrom）
  - 3个查询（totalSupply/balanceOf/allowance）
  - 只要满足以上接口的都是ERC20标准合约，很多土狗合约喜欢在transfer内魔改。
- 全局属性 `type(I).interfaceId` 使用？
  - 没啥用，就是类似函数签名一样的十六进制数据，知道有这个属性就好。
- 聊一聊 `interface`
  - 就像继承其他合约一样，合约可以继承接口。接口中的函数都会隐式的标记为
`virtual` ，意味着他们会被重写并不需要 `override` 关键字。
但是不表示重写（overriding）函数可以再次重写，仅仅当重写的函数标记为
`virtual` 才可以再次重写。