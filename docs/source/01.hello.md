# 01.初识

本章目录

- 1️⃣ 区块链基础
- 2️⃣ Hello World
- 3️⃣ 合约代码中的三种注释
- 4️⃣ 合约结构介绍
- 5️⃣ 全局的以太币单位
- 6️⃣ 接收 ETH
- 7️⃣ selfdestruct:合约自毁
- 🆗 实战: Hello Comrades
- 🆗 实战: WETH 合约
- 🆗 实战: 存钱罐合约
- 🆗 实战: 多签钱包
- #️⃣ 问答题

## 1️⃣ 区块链基础

Solidity 是在兼容 EVM 的区块链上开发智能合约的语言，我们不需要关心所在区块链底层逻辑，只要是兼容 EVM 的公链，我们都可以使用 Solidity 进行智能合约的编码。简单了解以下的区块链概念：

- 事务
- 交易
- 地址
- 区块
- 存储/内存/栈

### 事务

事务意味着你想做的事情，要么一点没做，要么全部完成。具有原子性，不存在修改一半的情况。

比如从 A 地址向 B 地址转账 100 元，那么数据库里 A 减 100 元，B 加 100 元。如果因为某些原因导致 A 已经减了 100 元，但是 B 加 100 元中间出现了异常。因为事务的原子性，发生失败后 A/B 地址都不会发生任何修改。这种场景在合约中经常发生，会经常看到 _[out of gas](https://etherscan.io/tx/0xda8c0b80d8e240a83c8f6b067c4656babeb13e8e0ece4fd4292aa06252f1285c)_ 异常，这是因为 gas 被耗尽。此时合约中做的所有修改都会被回滚。

gas:合约的手续费；是作为用户为当前交易支付的手续费，每一笔交易都会收取 gas 费，目的是限制交易需要做的工作量，需要做的事情越多，所花费的 gas 也就越多；gas 会按照特定规则进行逐渐消耗，如果执行完成后还有剩余，gas 会在当前交易内原路返回到交易发起者的地址中。

### 交易

交易可以看作一个地址发送到另外一个地址的消息，可能包含一个二进制数据和以太币。

- 如果目标地址含有代码，则此代码会被执行，并以 payload 作为入参。
- 如果目标地址是零地址，此交易将创建一个新合约。
  - 这时候用来创建合约的 payload 会被**转为 EVM 字节码**并**执行**，执行的输出作为合约代码永久存在区块链上。
  - 所以如果创建一个合约，并不需要向链上发送实际的合约代码，只需发送能够产生合约代码的代码就可以。

区块链中的交易遵守事务的特性。交易总是由发送人（创建交易的地址）进行签名。区块链底层会确保只有持有该地址密钥才能发起交易。正因为这个特性，所以才能为区块链上特定状态的修改增加保护机制。

比如在合约中指定某一个方法只有"管理员"账号可以用，我们只需要验证调用者是否为管理员地址就可以了，至于地址权限的保护事情并不需要关心，只要是该账号发起的交易，就认为是管理员在操作。安全方面我们需要考虑的是，如果某一个地址被盗了怎么样，通常这些是业务逻辑决定，比如多签钱包的业务。

### 地址

地址很多时候也被称为账户，EVM 中有两类地址，一类是外部地址，一类是合约地址。

- 外部地址：由**公钥-私钥对**控制
  - 常用的助记词，keystore 文件等只是方便用户储存，底层还是会转成私钥。
  - 一般是钱包应用创建的地址。公钥就是`0xABC`的这种以太坊收款地址，私钥可能是助记词生成，可能是 keystore 文件生成，也可能是用户直接保存的。
- 合约地址：由地址一起存储的代码控制。

无论外部地址，还是合约地址，对于 EVM 来说，都是一样的。每个地址都有一个键值对形式的持久化存储。其中 key 和 value 都是 256 位，我们称为存储。此外每个地址都会有一个以太币的余额，合约地址也是如此；余额会因为发送包含以太币的交易而改变。

### 区块

你可能听过区块链的双花攻击，女巫攻击等作恶方式。如果你没有听过也没有关系，因为它们对于智能合约开发来说并不重要，我们编写的 Solidity 代码能运行在以太坊网络，也可以运行在 BSC， Matic，Eos EVM 网络等，就像前文说的那样，无论他们采用什么底层逻辑，只要它们支持 EVM 就足够了，底层逻辑不用关心。

我们需要关心的是，**区块可能被回滚，交易可能被作废**，所以会出现你发起的交易被回滚甚至从区块链中抹除掉的可能。区块链不能保证当前的交易一定包含在下一个区块中。如果你开发的合约有顺序关系，要注意这个特性。合约内的逻辑，不能将某一个块作为依赖。

### 存储/内存/栈

**存储**：每一个地址都有一个持久化的内存，存储是将 256 位字映射到 256 位字的键值存储区。所以数据类型的最大值是 `uint256`/`int256`/`bytes32`，合约只能读写存储区内属于自己的部分。

**内存**：合约会试图为每一次消息调用获取一块被重新擦拭干净的内存实例。所以储存在内存中的数据，在函数执行完以后就会被销毁。内存是线性的，可按字节级寻址，但读的长度被限制为 256 位，而写的长度可以是 8 位或 256 位。

**栈**：合约的所有计算都在一个被称为栈（stack）的区域执行，栈最大有 1024 个元素，每一个元素长度是 256 bit；所以调用深度被限制为 1024 ，对复杂的操作，推荐使用循环而不是递归。

## 2️⃣ Hello World

Solidity 合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。 调用另一个合约实例中函数时，会切换执行时的上下文，此时前一个合约的状态变量就不能访问了。后面会逐步展开介绍，国际惯例，使用当前语言的 Hello World 作为第一个例子。

### 例子代码

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Hello {
    // 24509 gas
    string public message = "Hello World!"; // 状态变量

    // 24473
    function fn1() public view returns (string memory) {
        return message;
    }

    // 21801. 内存中直接返回
    function fn2() public pure returns(string memory){
        return "Hello World!";
    }

    // 21880
    function fn3() public pure returns(string memory){
        return fn2(); // 使用方法；函数调用函数，没有this。直接调用
    }
}
```

### remix 编译，部署，运行

Remix IDE 是学习合约的好帮手，即开即用，无需各种依赖，让我们可以专注于合约的学习和开发。我们需要了解基本的 Remix 部署和代码测试。

**1.编写代码**：点击左侧 **File explorer**，然后点击 _Create new file_ 图标，创建 `helloword.sol` 文件，文件内容就是 Hello World 例子。

**2.编译代码**：点击左侧 **Solidity compile**，然后点击 `Compile helloword.sol`，出现绿色的"对号"就是 compilation successful 了。（小技巧：选中此页面的 _Auto compile_ 可以自动编译最新修改保存后的代码，推荐选中此选项。）

**3.部署合约**：点击左侧 **Deploy & run transactions** 页面，点击黄色按钮 「Depoly」，此时按钮下方区域会出现**Deployed Contracts**，这里就是刚刚部署出来的合约地址。

**4.运行合约**：展开**Deployed Contracts**中刚部署的合约，找到刚刚部署的 Hello 合约，点击 `message`/`fn1`/`fn2`/`fn3` 按钮都可以读取到`"Hello World!"`内容。

<!-- ![](/_static/01/001.png) -->

### Hello World 例子分析

上面的代码获取 message 可以得到 `"Hello World!"`,调用 `fn1()`函数，也可以得到 `"Hello World!"`; 这是因为 `fn1` 里面的逻辑是返回 message。通过这个例子可以发现，合约内调用变量并不需要使用 `this` 之类的关键字，直接使用即可，调用函数也是如此，直接 `fnName([x])` 就可以。

通过 Remix 调用详情我们可以发现，他们消耗的 gas 不相同。通常直接获取 `message` 更省钱，因为`message`储存在状态变量中，而函数`helloWorld`是读取了状态变量然后再返回出去。但是在 Remix 中有时候得到的结果却并不相同，不用太相信 Remix 内的 gas。在 Remix 中，代码顺序，变量名/函数名长短的修改都可以大大影响 gas 消耗，不要太相信 Remix 的 ga 消耗。

在编写 solidity 代码时，保证安全的前提下，让合约消耗更少的 gas 是一个重要的优化方向。后面会有专门的一章进行 gas 优化的探讨，这里不再多展开。

## 3️⃣ 合约代码中的三种注释

我们看到第一行的代码是 `// SPDX-License-Identifier: MIT` 这里面的 `//` 符号，是注释符。用来标记和记录代码开发相关的事情，注释的内容是不会被程序运行，Solidity 支持单行注释和块注释，注释是为了更好的解释代码。**请不要相信好的代码不需要注释这种鬼言论**。代码中加入注释可以更好的团队协作，让自己更好的进行代码开发，以及让阅读者更快捷的理解代码逻辑。在实际工作中经常会出现自己写的代码一年半载之后再看，复杂些的逻辑可能需要浪费很多时间在代码理解上，如果再没有设计图和代码注释，简直想骂人。

Solidity 支持 3 种注释方式；

- 单行注释
- 块注释
- NatSpec 描述注释

### 1.单行注释

格式: `// 注释内容`

```
// SPDX-License-Identifier: MIT
```

```
string message = "Hello World!"; // 这是单行注释
```

如上，`//` 后面的内容都会被编译器忽略，为了可读性，一般会在`//`后面加一个空格。

### 2.块注释

格式如下，在 `/*` 与 `*/` 之间的内容，都被编译器忽略

```
/*
这是块注释
*/
```

为了可读性，一般块注释的行首都加 `*` 和空格，如下

```
/**
  * 这是块注释
  * 这是块注释
  */
```

### 3.NatSpec 描述注释

单行使用 `///` 开始，多行使用 `/**` 开头以 `*/` 结尾。NatSpec 描述注释的作用非常重要，它是为函数、返回变量等提供丰富的文档。在编写合约的时候，强烈推荐使用 `NatSpec` 为所有的开放接口（只要是在 `ABI` 里呈现的内容）进行完整的注释。

#### 简单演示

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/// @title  一个简单的数据存储演示
/// @author Anbang
/// @notice 您智能将此合约用于最基本的演示
/// @dev    提供了存储方法/获取方法
/// @custom:xx    自定义的描述/这个是实验的测试合约
contract  TinyStorage {
    // data
    uint256 storedData;

    /// @notice 储存 x
    /// @param _x: storedData 将要修改的值
    /// @dev   将数字存储在状态变量 storedData 中
    function set(uint256 _x) public{
        storedData = _x;
    }

    /// @notice 返回存储的值
    /// @return 储存值
    /// @dev   检索状态变量 storedData 的值
    function get() public view returns(uint256){
        return storedData;
    }


    /**
     * @notice 第二种写法
     * @param _x: XXXXX
     * @dev   XXXXX
     * @return XXXXX
     * @inheritdoc : 
     */
}
```

上面所有标签都是可选的。下表解释了每个 NatSpec 标记的用途以及可以使用在哪些位置。我们可以选择合适的标记进行记录

| 标签          | 说明                                               | 语境                                                               |
| ------------- | -------------------------------------------------- | ------------------------------------------------------------------ |
| `@title`      | 描述 contract/interface 的标题                     | contract, interface, library                                       |
| `@author`     | 作者姓名                                           | contract, interface, library                                       |
| `@notice`     | 向最终用户解释这是做什么的                         | contract, interface, library,<br/>function, 公共状态变量<br/>event |
| `@dev`        | 向开发人员解释任何额外的细节                       | contract, interface, library,<br/>function, 状态变量, event        |
| `@param`      | 记录参数（后面必须跟参数名称）                     | function, event,<br/>自定义错误                                    |
| `@return`     | 函数的返回变量                                     | function, 公共状态变量                                             |
| `@inheritdoc` | 从基本函数中复制所有缺失的标签（必须后跟合约名称） | function, 公共状态变量                                             |
| `@custom:...` | 自定义标签，语义由应用程序定义                     | 所有位置均可以                                                     |

#### 文档输出

使用 `NatSpec` 描述注释的另一个好处是，当被编译器解析时，上面示例中的代码将生成两个不同的 JSON 文件。

- User Documentation：供最终用户在执行功能时作为通知使用的
- Developer Documentation：供开发人员使用的。

如果将上述合约另存为，`a.sol` 则您可以使用以下命令生成文档：

```
solc --userdoc --devdoc a.sol
```

#### 继承说明

TODO: 在后面合约继承的时候再演示使用。

如果函数是继承别的合约，没有 NatSpec 的函数将自动继承其基本函数的文档。但是下面三种情况是例外的：

- 当参数名称不同时。
  - 这时候是函数的重载，函数签名已经发生了改变。
- 当有多个基本功能时。
  - 这时候因为发生了冲突，supper 中有多个父级
- 当有一个明确的 `@inheritdoc` 标签指定应该使用哪个合约来继承时。

更多 NatSpec 请参考: <https://github.com/aragon/radspec>

## 4️⃣ 合约结构介绍

1. SPDX 版权声明
    - https://spdx.org/licenses/
2. pragma solidity 版本限制
3. contract 关键字
4. import 导入声明
5. interface: 接口
6. library:库合约

### 1.SPDX 版权声明

第 1 行 `// SPDX-License-Identifier: MIT` 就是合约的版权声明。其中 **SPDX-License-Identifier**(SPDX 许可标示) 是标注当前的智能合约采用什么样的对外开放标准，该标准规定了别人是否拥有商业开发，学习使用等权利。代码中使用的 `MIT` 规定了其他人随便用该代码，但出问题不负责。[MIT 详细解释](https://spdx.org/licenses/MIT.html)；SPDX 许可标示的注释在文件的任何位置都可以被编译器识别到的，按照规范建议把它放在文件的顶部第一行。

如果一个项目开源了智能合约的源代码，可以更好地建立社区信任。但是由于提供源代码就不可避免的涉及到版权或者法律问题。所以 solidity 鼓励开源，但是开源并不等于放弃版权。如果你不想指定任何许可证，或者代码就是不想开源，Solidity 推荐使用 `UNLICENSED` ;`UNLICENSED` 不存在于 SPDX 许可证列表中,与 UNLICENSE （授予所有人所有权利）不同，它比 `UNLICENSE` 多一个 `D` 字母。

需要注意: 源代码这里，编译器不会验证 SPDX 许可标示是否符合规范，比如我可以写为 `// SPDX-License-Identifier: ANBANG` ，并不会影响代码的运行。但是这里的标示会被打包在 `bytecode metadata` 里。

#### 1. bytecode metadata 介绍

当我们使用 `remix` 编译合约的时候，会在根目录创建 `artifacts` 文件夹，其中包含 `build-info` 记录构建信息的文件夹，以及每个合约名字作为文件名的文件夹，比如 `contract Hello` 将生成

- `Hello.json` 文件
- `Hello_metadata.json` 文件

#### 2. `Hello.json` 文件结构

```
{
  deploy: {},
  data: {
    bytecode: {},
    deployedBytecode: {},
    gasEstimates: {},
    methodIdentifiers: {},
  },
  abi: [],
};
```

#### 3. `Hello_metadata.json` 文件结构

```
{
  compiler: {
    version: "0.8.17+commit.xxx",
  },
  language: "Solidity",
  output: {
    abi: [],
    devdoc: {},
    userdoc: {},
  },
  settings: {},
  sources: {
    "aaa.sol": {
      keccak256:
        "0x637c141739144cd991b9350336a1f8c3b948811d7ed743fefb4aad99d7bb362f",
      license: "ANBANG",
      urls: [
        "bzz-raw://9eea517225b90242d6e3761046f5f5a8f0a2393747c89f3af01f34ad00764dc4",
        "dweb:/ipfs/QmXp5wap9ZNC9fihdA7aLMe7bKWBjeAuv7khEuvKrgp9Bx",
      ],
    },
  },
  version: 1,
};
```

`// SPDX-License-Identifier: ANBANG` 中的 `ANBANG` 就是在 `sources -> filename.sol -> license` 中

- **总结:**
  1. 根据自己的合约情况，选择合适的版权声明可以避免很多不必要的版权麻烦。
- **扩展:**
  1. 更多的 SPDX-License-Identifier 类型介绍，参照文章 [SPDX License List](https://spdx.org/licenses/) 详细阅读。
  2. Solidity 遵循 [npm 的 license 建议](https://docs.npmjs.com/cli/v7/configuring-npm/package-json#license)
  3. 更多的 bytecode metadata 参照文章 [合约的 metadata](#)

### 2.pragma solidity 版本限制

第 2 行 `pragma solidity ^0.8.17;` 指令，它是告诉编译器，我当前的合约代码采用的是 Solidity 0.8.17 这个版本为基础编写的，解析部署时需要在匹配的版本下进行，在区块链浏览器上进行合约验证时，也需要选择匹配的版本。

#### 使用 `^` 的意义和优点

而 `^0.8.17` 中的 `^` 表示小版本兼容，大版本不兼容，相当于 `pragma solidity >= 0.8.17 < 0.9.0;`。他既不允许低于`0.8.17`的编译器编译，也不允许大于等于 `0.9.0` 版本的编译器进行编译。之所以这么写，不写死 `pragma solidity 0.8.17;` 是为了可以享受到编译器的补丁版，比如以后出来了 `0.8.40` 版本，那么当前合约是可以运行在未来的 `0.8.40` 这个新版本的编译器。但是如果是大版本升级到了 `0.9.0`，那么编译器不会用新版的`0.9.x`解析，会使用 0.8 的最后一个稳定版本来进行解析编译。这里如果不加 `^`,直接写`pragma solidity 0.8.17;`,就是告诉编译器，当前合约只选择在 `0.8.17` 版本来编译和部署；这样做的缺点就是享受不到以后出的补丁版的编译器。

#### 跨大版本的合约

如果你打算跨大版本的合约，可以使用`>` /`>=`/`<`/`<=`来操作，比如 `pragma solidity >=0.7.0 <0.9.0;`。

注意：`pragma` 指令只对当前的源文件起作用，如果把文件 `B` 导入到文件 `A`，文件 B 的 pragma 将不会自动应用于文件 A。

- **总结:**
  1. `pragma solidity ^0.8.17;` 是用来告诉编译器应该选择什么版本来解析编译当前代码。
  2. `pragma` 指令只对当前的源文件起作用。

注：一份源文件可以包含**多个版本声明**、多个导入声明和多个合约声明。

### 3.contract 关键字

第 3 行的 `contract Hello {}` 是合约的基本结构；其中 `contract` 声明了当前代码块内是一个完整的合约。而 `Hello` 是当前合约的名字，合约名称是必须的，首字母一般采用大写字母开头。

`contract` 代表特殊的意义，这种有特殊意义的词，在编程界里一般被称为 `保留关键字`；保留关键字是现在或者将来被用到的特殊代指，都有固定意义，所以保留关键字不能作为变量名和函数名字。

- **总结:**
  1. contract 基本结构是 `contract ContractName {}`
  2. Solidity 合约中，合约的名字是必须的。
  3. 合约的名称，一般约定为 大驼峰命名方式
  4. contract 是保留关键字
  5. 保留关键字不能作为变量名和函数名
- **扩展:**
  1. 合约的编写规范，参照 [合约编码规范](/forever/903.styleguide.md)
  2. 更多保留关键字，参照 [变量名命名规则](/source/03.variable.html#id11) 详细阅读。

注：一份源文件可以包含多个版本声明、多个导入声明和**多个合约声明**。

#### 变量

合约内的 `message` 叫做状态变量，状态变量是永久地存储在合约存储中的值。关于变量的更多信息，会在后续 [变量](/source/03.variable.html) 那一章详细介绍

#### 函数

函数是代码的可执行单元，是一组逻辑的集合。关于变量的更多信息，会在后续 [函数](/source/04.function.html) 那一章详细介绍

#### this 关键字

Solidity 中 `this` 代表合约对象本身；

- 可以通过 `address(this)` 获取合约地址。
- 可以通过 `this.fnName` 获取 external 函数

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    function contractAds() external view returns (address) {
        return address(this);
    }

    function testExternal() external view returns (address) {
        return this.contractAds();
    }
}
```

#### 合约地址/合约创建者地/合约调用者地址

这三个地址概念一定要完全理解。

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// 这三个地址的概念一定要理解清楚
contract Demo {
    address public owner;

    constructor() {
        // 可以用在 constructor 内获取当前合约地址
        owner = address(this);

        // 不可以在构造函数内调用函数，因为此时合约还没有完成构建好。
        // this.caller(); 相当于从外部调用 caller 方法
        // owner = this.caller();
    }

    function caller() external view returns (address) {
        return this.contractAds(); // 内部调用 external 可见性的函数
    }

    function contractAds() external view returns (address) {
        return address(this);
    }
}
```

#### 合约属性:type 关键字

- `type(C).name`:获得合约名
- `type(C).creationCode`:获得包含创建合约字节码的内存字节数组。它可以在内联汇编中构建自定义创建例程，尤其是使用 create2 操作码。 不能在合约本身或派生的合约访问此属性。 因为会引起循环引用。
- `type(C).runtimeCode`:获得合约的运行时字节码的内存字节数组。这是通常由 C 的构造函数部署的代码。 如果 C 有一个使用内联汇编的构造函数，那么可能与实际部署的字节码不同。 还要注意库在部署时修改其运行时字节码以防范定期调用（guard against regular calls）。 与 .creationCode 有相同的限制，不能在合约本身或派生的合约访问此属性。 因为会引起循环引用。

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Hello {
    string public message = "Hello World!";
}

contract Demo {
    function name() external pure returns (string memory) {
        return type(Hello).name;
    }

    function creationCode() external pure returns (bytes memory) {
        return type(Hello).creationCode;
    }
    function runtimeCode() external pure returns (bytes memory) {
        return type(Hello).runtimeCode;
    }
}
```

除了上面介绍的版权声明，版本限制，contract 外，合约文件还包括 `import`, `interface`,`library`，一起展开介绍下

### 4.import 导入声明

功能：从其他文件内倒入需要的变量或者函数。

#### 导入方式

既可以导入**本地文件**，也可以导入 **url**(网络上的 ipfs，http 或者 git 文件)

1. **导入所有的全局标志** `import "filename";` 到当前全局范围
   1. 导入本地文件:`import "./ERC20.sol";`，其中`./`表示当前目录，查找路径参考
   2. 导入网络文件:`import "https://github.com/aaa/.../tools.sol";`
   3. 导入本地 NPM 库:
      1. `$ npm install @openzeppelin/contracts`
      2. `import "@openzeppelin/contracts/token/ERC721/ERC721.sol";`
2. **导入所有的全局标志，并创建新的全局符号**
   1. 方式一: `import * as symbolName from "filename";`
   2. 方式二: `import "filename" as symbolName;`
3. 按需导入，按需修改名称
   1. `import {symbol1 as aliasName, symbol2} from "filename";`

不推荐导入变量标示名到当前全局范围的方式，因为不可控，容易污染当前的命名空间。如果全局导入，推荐使用 `import "filename" as symbolName;`

注：一份源文件可以包含多个版本声明、多**个导入声明**和多个合约声明。

#### 导入时候的本地路径

上文中的 filename 总是会按路径来处理，以 `/` 作为目录分割符、以 `.` 标示当前目录、以 `..` 表示父目录。 当 `.` 或 `..` 后面跟随的字符是 `/` 时，它们才能被当做当前目录或父目录。 只有路径以当前目录 `.` 或父目录 `..` 开头时，才能被视为相对路径。

用 `import "./x.sol" as x;` 语句导入当前源文件同目录下的文件 `x.sol` 。 如果用` import "x.sol" as x;` 代替，可能会引入不同的文件（在全局 `include directory` 中）。

最终导入哪个文件取决于编译器（见下文）到底是怎样解析路径的。 通常，目录层次不必严格映射到本地文件系统， 它也可以映射到能通过诸如 ipfs，http 或者 git 发现的资源。

### 5.interface: 接口

**接口使用案例**

在下面的例子中，定义了 cat 合约以及 dog 合约。他们都有 `eat` 方法.以此他们都可以被上面的 `animalEat` 接口所接收。

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Cat {
    uint256 public age;

    function eat() public returns (string memory) {
        age++;
        return "cat eat fish";
    }

    function sleep1() public pure returns (string memory) {
        return "sleep1";
    }
}

contract Dog {
    uint256 public age;

    function eat() public returns (string memory) {
        age += 2;
        return "dog miss you";
    }

    function sleep2() public pure returns (string memory) {
        return "sleep2";
    }
}

interface AnimalEat {
    function eat() external returns (string memory);
}

contract Animal {
    function test(address _addr) external returns (string memory) {
        AnimalEat general = AnimalEat(_addr);
        return general.eat();
    }
}
```

#### `type(I).interfaceId`

返回接口`I` 的 `bytes4` 类型的接口 ID，接口 ID 参考： [EIP-165](https://learnblockchain.cn/docs/eips/eip-165.html) 定义的， 接口 ID 被定义为 XOR （异或） 接口内所有的函数的函数选择器（除继承的函数。

上面的代码种，可以增加如下的函数来查看 `interfaceId`;

```
contract Animal {
    // ...
    function interfaceId() external pure returns (bytes4) {
        return type(AnimalEat).interfaceId;
    }
}
```

更多内容在 [interface:接口](/source/13.interface.html) 那一章详细介绍。

### 6.library:库合约

库与合约类似，但它的目的是在一个指定的地址，且仅部署一次，然后通过 EVM 的特性来复用代码。

```
library Set {
    struct Data { mapping(uint => bool) flags; }
    function test(){
    }
}
```

其他合约调用库文件的内容直接通过库文件名.方法名例如：`Set.test()`。

更多内容在 [Library:库](/source/14.library.html) 那一章详细介绍。

## 5️⃣ 全局的以太币单位

现实生活中经常会听说，提现 1.5 个以太币，或者某笔交易手续费花了 0.02 个以太坊等。这些带有小数点的数字是日常交流使用的。但是在合约内，却没有这种小数概念的货币金额。比如 1 个 ETH 的金额是 `10**18 wei`，但是为了方便合约开发者操作，也提供如下这种便捷的换算方式。

以太币单位之间的换算就是在数字后边加上 `wei`、 `gwei`、 `ether` 来实现的，如果后面没有单位，缺省为 `wei`。例如 `1 ether == 1e18` 的逻辑判断值为 true。

- `1 ether = 1 * 10^18 wei`
- `1 ether = 1 * 10^9 gwei`

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    // 返回 true
    function test() public pure returns (bool a,bool b,bool c) {
        a = 1 wei == 1;
        b = 1 gwei == 1e9;
        c = 1 ether == 1e18;
    }
}
```

### 变量使用以太币单位

**注意: 这些后缀不能直接用在变量后边**。如果想用以太币单位来计算输入参数，你可以使用乘法来转换: `amountEth * 1 ether`

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Demo {
    uint256 public amount;

    constructor() {
        amount = 1;
    }

    function fnEth() public view returns (uint256) {
        return amount + 1 ether; // 1000000000000000001
    }

    function fnGwei() public view returns (uint256) {
        return amount + 1 gwei; // 1000000001
    }

    // 这些后缀不能直接用在变量后边。如果想用以太币单位来计算输入参数，你可以用如下方式来完成：
    function testVar(uint256 amountEth) public view returns (uint256) {
        return amount + amountEth * 1 ether;
    }
}
```
