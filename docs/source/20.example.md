# 20.真实项目分析

<style>
img {
    max-width: 100%;
    height: auto;
}
</style>

## ERC20

### ERC20规范

ERC20约定了一个代币合约需要实现的接口：

```
interface IERC20 {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);
}
```

上面的代码是一个标准的ERC20标准的代码, 规范给出了框架, 我们只需要实现相应的函数就好了, 这里给出函数说明。

### 扩展接口

```
interface IERC20Metadata is IERC20 {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
}
```

### 接口函数说明

函数的形参是局部有效, 所以前面使用下划线, 与其他的变量区别开来. 如 \_owner.

*   totalSupply() 函数返回这个Token的总发行量;
*   balanceOf() 查询某个地址的Token数量 , 结合mapping实现
*   transfer() owner 使用这个进行发送代币
*   transferFrom () token的所有者用来发送token
*   allowance() 控制代币的交易，如可交易账号及资产, 控制Token的流通
*   approve() 允许用户可花费的代币数；

### 事件函数说明

这里两个Event是重点, 事件,可以被前端js代码捕获到并进行相应的处理：

* event Transfer() Token的转账事件
* event Approval() 允许事件

### ERC20代币合约实现

理解了上面的函数, 下面的代码,就实现了Token合约的函数填充

```
contract ERC20 is IERC20 {
    // 状态变量
    string public name;
    string public symbol;
    uint8 public immutable decimals;

    address public immutable owner;

    // uint256 public immutable totalSupply; // 不增加总量
    uint256 public totalSupply; // 总价总量
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    // 函数修改器
    modifier onlyOwner() {
        require(msg.sender == owner, "not owner");
        _;
    }

    // 构造函数
    constructor(
        string memory _name,
        string memory _symbol,
        uint8 _decimals,
        uint256 _totalSupply
    ) {
        owner = msg.sender;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balanceOf[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    // 1个授权
    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    // 2个交易
    function transfer(address recipient, uint256 amount)
        external
        returns (bool)
    {
        balanceOf[msg.sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool) {
        // msg.sender 也就是当前调用者，是被批准者
        allowance[sender][msg.sender] -= amount;
        balanceOf[sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    // 1个铸币 - 非必须
    function mint(uint256 amount) external onlyOwner returns (bool) {
        totalSupply += amount;
        balanceOf[msg.sender] += amount;
        emit Transfer(address(0), msg.sender, amount);
        return true;
    }

    // 1个销毁 - 非必须
    function burn(uint256 amount) external returns (bool) {
        totalSupply -= amount;
        balanceOf[msg.sender] -= amount;
        emit Transfer(msg.sender, address(0), amount);
        return true;
    }
}
```

### 构造函数

```
// 构造函数
constructor(
    string memory _name,
    string memory _symbol,
    uint8 _decimals,
    uint256 _totalSupply
) {
    owner = msg.sender;
    name = _name;
    symbol = _symbol;
    decimals = _decimals;
    totalSupply = _totalSupply;
    balanceOf[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
}
```

构造函数的是不能有返回值的(有也无法接受), 但是可以带参数, 像是此处代码, 把发行量, token的名称和token的 符号作为参数留出. 在合约初始化时候我们便可以自行定义.

### 映射(mapping)

```
mapping(address => uint256) public balanceOf;
mapping(address => mapping(address => uint256)) public allowance;
```

address 到 uint类型的映射关系.

```
balanceOf[msg.sender] = 10000;  //msg.sender 是一个地址
```

## ERC721

和ERC20一样，ERC721同样是一个代币标准，此代币英文是 Non-Fungible Tokens，简写为NFT，即非同质代币。

非同质代币(NFT)是一种具有唯一性识别的代币 ，ERC-20 Token可以无限细分为10^18份，而ERC721的Token最小的单位为1，无法再分割。由于ERC721代币具有唯一性，不可分割的特点，所以很容易和一些具体的物品关联起来，通过这样一个标准，可以更广泛的应用到实际场景中。

### ERC165

每个符合ERC721的智能合约必须同时符合ERC721和ERC165。ERC165是智能合约定义自己支持哪些接口的一种方式。 那么比如说，智能合约是否支持接收ERC-721代币？ 如果支持，则该合约的 supportsInterface 函数必须存在并返回true。

ERC165标准接口如下：

- `function supportsInterface`

```
interface ERC165 {
    /// @notice 是否合约实现了接口
    /// @param interfaceID  ERC-165定义的接口id
    /// @dev 函数要少于  30,000 gas.
    /// @return 合约实现了 `interfaceID`（不为  0xffffffff）返回`true` ， 否则false.
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}
```


### ERC721标准

基于 ERC721标准接口如下
- **event** 3个
  - `event Transfer`
  - `event Approval`
  - `event ApprovalForAll`
- **查询**
  - `function balanceOf`
  - `function ownerOf`
  - `function getApproved`
    - 获取单个NFT的授权地址
  - `function isApprovedForAll`
    - 查询一个地址是否是另一个地址的授权操作员
- **操作**
  - `function approve`
  - `function transferFrom`
  - `function setApprovalForAll`
  - `function safeTransferFrom` 2个，一个有data

```
interface IERC721 is IERC165 {
    /// @dev 当任何NFT的所有权更改时（不管哪种方式），就会触发此事件。
    ///  包括在创建时（`from` == 0）和销毁时(`to` == 0), 合约创建时除外。
    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);

    /// @dev 当更改或确认NFT的授权地址时触发。
    ///  零地址表示没有授权的地址。
    ///  发生 `Transfer` 事件时，同样表示该NFT的授权地址（如果有）被重置为“无”（零地址）。
    event Approval(
        address indexed _owner, 
        address indexed _approved, 
        uint256 indexed _tokenId);

    /// @dev 所有者启用或禁用操作员时触发。（操作员可管理所有者所持有的NFTs）
    event ApprovalForAll(
        address indexed _owner, 
        address indexed _operator, 
        bool _approved);

    /// @notice 统计所持有的NFTs数量
    /// @dev NFT 不能分配给零地址，查询零地址同样会异常
    /// @param _owner ： 待查地址
    /// @return 返回数量，也许是0
    function balanceOf(address _owner) external view returns (uint256);

    /// @notice 返回所有者
    /// @dev NFT 不能分配给零地址，查询零地址抛出异常
    /// @param _tokenId NFT 的id
    /// @return 返回所有者地址
    function ownerOf(uint256 _tokenId) external view returns (address);

    /// @notice 将NFT的所有权从一个地址转移到另一个地址
    /// @dev 如果`msg.sender` 不是当前的所有者（或授权者）抛出异常
    /// 如果 `_from` 不是所有者、`_to` 是零地址、`_tokenId` 不是有效id 均抛出异常。
    ///  当转移完成时，函数检查  `_to` 是否是合约，如果是，调用 `_to`的 `onERC721Received` 
    ///  并且检查返回值是否是 `0x150b7a02` 
    ///  (即：`bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`)
    ///  如果不是抛出异常。
    /// @param _from ：当前的所有者
    /// @param _to ：新的所有者
    /// @param _tokenId ：要转移的token id.
    /// @param data : 附加额外的参数（没有指定格式），传递给接收者。
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) 
        external payable;

    /// @notice 将NFT的所有权从一个地址转移到另一个地址，功能同上，不带data参数。
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) 
        external payable;

    /// @notice 转移所有权 -- 调用者负责确认`_to`是否有能力接收NFTs，否则可能永久丢失。
    /// @dev 如果`msg.sender` 不是当前的所有者（或授权者、操作员）抛出异常
    /// 如果 `_from` 不是所有者、`_to` 是零地址、`_tokenId` 不是有效id 均抛出异常。
    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;

    /// @notice 更改或确认NFT的授权地址
    /// @dev 零地址表示没有授权的地址。
    ///  如果`msg.sender` 不是当前的所有者或操作员
    /// @param _approved 新授权的控制者
    /// @param _tokenId ： token id
    function approve(address _approved, uint256 _tokenId) external payable;

    /// @notice 启用或禁用第三方（操作员）管理 `msg.sender` 所有资产
    /// @dev 触发 ApprovalForAll 事件，合约必须允许每个所有者可以有多个操作员。
    /// @param _operator 要添加到授权操作员列表中的地址
    /// @param _approved True 表示授权, false 表示撤销
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice 获取单个NFT的授权地址
    /// @dev 如果 `_tokenId` 无效，抛出异常。
    /// @param _tokenId ：  token id
    /// @return 返回授权地址， 零地址表示没有。
    function getApproved(uint256 _tokenId) external view returns (address);

    /// @notice 查询一个地址是否是另一个地址的授权操作员
    /// @param _owner 所有者
    /// @param _operator 代表所有者的授权操作员
    function isApprovedForAll(address _owner, address _operator) 
        external view returns (bool);
}
```

  

### 扩展接口

#### IERC721Receiver:接受安全转账接口

如果合约（应用）要接受NFT的安全转账，则必须实现如下接口。

```
interface ERC721TokenReceiver {
    /// @notice 处理接收NFT
    /// @dev ERC721智能合约在`transfer`完成后，在接收这地址上调用这个函数。
    /// 函数可以通过revert 拒绝接收。返回非`0x150b7a02` 也同样是拒绝接收。
    /// 注意: 调用这个函数的 msg.sender是ERC721的合约地址
    /// @param _operator ：调用 `safeTransferFrom` 函数的地址。
    /// @param _from ：之前的NFT拥有者
    /// @param _tokenId ： NFT token id
    /// @param _data ： 附加信息
    /// @return 正确处理时返回 
    ///    `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`
    function onERC721Received(
        address _operator, 
        address _from, 
        uint256 _tokenId, 
        bytes _data) 
        external returns(bytes4);
}
```

#### IERC721Metadata:元数据接口

元数据包括一个名称和符号，就像它许多其他代币标准中一样（如ERC-20）。 此外，还可以为一个代币定义tokenURI ， 每个代币都应该有自己的URI。

```
interface IERC721Metadata is IERC721 {
    /// @notice NFTs 集合的名字
    function name() external view returns (string _name);

    /// @notice NFTs 缩写代号
    function symbol() external view returns (string _symbol);

    /// @notice 一个给定资产的唯一的统一资源标识符(URI)
    /// @dev 如果 `_tokenId` 无效，抛出异常. URIs在 RFC 3986 定义，
    /// URI 也许指向一个 符合 "ERC721 元数据 JSON Schema" 的 JSON 文件
    function tokenURI(uint256 _tokenId) external view returns (string);
}
```

#### IERC721Enumerable:枚举接口

枚举接口包含了按索引获取到对应的代币，可以提供NFTs的完整列表，以便NFT可被发现。

```
interface IERC721Enumerable is IERC721 {
    /// @notice  NFTs 计数
    /// @return  返回合约有效跟踪（所有者不为零地址）的 NFT数量
    function totalSupply() external view returns (uint256);

    /// @notice 枚举索引NFT
    /// @dev 如果 `_index` >= `totalSupply()` 则抛出异常
    /// @param _index 小于 `totalSupply()`的索引号
    /// @return 对应的token id（标准不指定排序方式)
    function tokenByIndex(uint256 _index) external view returns (uint256);

    /// @notice 枚举索引某个所有者的 NFTs
    /// @dev  如果 `_index` >= `balanceOf(_owner)` 或 `_owner` 是零地址，抛出异常
    /// @param _owner 查询的所有者地址
    /// @param _index 小于 `balanceOf(_owner)` 的索引号
    /// @return 对应的token id （标准不指定排序方式)
    function tokenOfOwnerByIndex(address _owner, uint256 _index) 
        external view returns (uint256);
}
```

## Uniswap V2

https://hackmd.io/@adshao/rk7nI-EG9

Uniswap智能合约代码由两个github项目组成。一个是[core](https://github.com/Uniswap/v2-core)，一个是[periphery](https://github.com/Uniswap/v2-periphery)。

其中，core合约仅包含最基础的交易功能，核心代码很精简，由于用户资金都存储在core合约里，因此需要保证core合约最简化，避免引入bug；periphery合约则针对用户使用场景提供多种封装方法，比如支持原生ETH交易（自动转为WETH），多路径交换（一个方法同时执行A→B→C交易）等，其底层调用的是core合约。

![](https://i.imgur.com/J9txqxI.png)

- **core**:偏核心逻辑，单个swap的逻辑。
  - 这里有3个合约文件: `UniswapV2ERC20` , `UniswapV2Pair` `，UniswapV2Factory`
  - `UniswapV2Factory` ：工厂合约，用于创建Pair合约（以及设置协议手续费接收地址）
  - `UniswapV2Pair` ：Pair（交易对）合约，定义和交易有关的几个最基础方法，如swap/mint/burn，价格预言机等功能，其本身是一个ERC20合约，继承UniswapV2ERC20
  - `UniswapV2ERC20` ：实现ERC20标准方法
  - 核心逻辑实现在 `UniswapV2Pair` 中, `UniswapV2Factory`中仅仅只是`createPair`以及`feeTo`和`feeToSetter`. `createPair` 内部是使用 `UniswapV2Pair` 的bytecode，使用 `token0` 和 `token1` 作为**salt**，做的`create2`.
  - 单个swap，两种代币形成的交易对,叫`pair`，俗称"池子"。
  - 每个交易对有一些基本属性：`reserve0`/`reserve1`以及`totalSupply`。
  - `reserve0`/`reserve1`是交易对的两种代币的储存量。
  - `totalSupply`是当前流动性代币的总量。每个交易对都对应一个流动性代币（LP Token / liquidity provider token）。LP Token记录了所有流动性提供者的贡献。所有流LP Token 的总和就是`totalSupply`。
  - Uniswap协议的思想是 `reserve0`*`reserve1` 的乘积不变。
- **periphery**:偏外围服务，一个个swap的基础上构建服务。
  - 核心逻辑实现在 `UniswapV2Router02.sol` 中。称为Router，Periphery实现了“路由”，支持各个swap之间的连接。
  - 主要实现了三个功能：`add liquidity` / `remove liqudity` / `swap`
  - UniswapV2Router02：最新版的路由合约，相比UniswapV2Router01增加了对FeeOnTransfer代币的支持；实现Uniswap v2最常用的接口，比如添加/移除流动性，使用代币A交换代币B，使用ETH交换代币等
  - UniswapV1Router01：旧版本Router实现，与Router02类似，但不支持FeeOnTransferTokens，目前已不使用

结合两部分一起看。核心是在Pair中管理了reserve和total supply。所有提供的流动性都以流动性Token来衡量，所有Token的总和就是total supply。

### core 逻辑

Core逻辑实现了单个交易对的逻辑。通过UniswapV2Factory可以创建一个个Pair（交易池）。

#### UniswapV2Factory

首先将token0 token1按照顺序排序，确保token0字面地址小于token1。

```
function createPair(address tokenA, address tokenB) 
  external returns (address pair) {
    require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');
    (address token0, address token1) = tokenA < tokenB 
        ? (tokenA, tokenB) 
        : (tokenB, tokenA);
    require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');
    // single check is sufficient
    require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); 
    bytes memory bytecode = type(UniswapV2Pair).creationCode;
    bytes32 salt = keccak256(abi.encodePacked(token0, token1));
    assembly {
        pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
    }
    IUniswapV2Pair(pair).initialize(token0, token1);
    getPair[token0][token1] = pair;
    getPair[token1][token0] = pair; // populate mapping in the reverse direction
    allPairs.push(pair);
    emit PairCreated(token0, token1, pair, allPairs.length);
}
```
实际上在最新版的EMV中，已经直接支持给new方法传递salt参数，如下所示：`pair = new UniswapV2Pair{salt: salt}();`,因为Uniswap v2合约在开发时还没有这个功能，所以使用assembly create2。

#### UniswapV2ERC20

这个合约主要定义了UniswapV2的ERC20标准实现，代码比较简单。这里介绍下permit方法：

```
function permit(
    address owner, 
    address spender, 
    uint value, 
    uint deadline, 
    uint8 v, 
    bytes32 r, 
    bytes32 s) 
    external {
    require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');
    bytes32 digest = keccak256(
        abi.encodePacked(
            '\x19\x01',
            DOMAIN_SEPARATOR,
            keccak256(abi.encode(PERMIT_TYPEHASH, owner, 
            spender, value, nonces[owner]++, deadline))
        )
    );
    address recoveredAddress = ecrecover(digest, v, r, s);
    require(recoveredAddress != address(0) && recoveredAddress == owner, 
        'UniswapV2: INVALID_SIGNATURE');
    _approve(owner, spender, value);
}
```
permit方法实现的就是白皮书2.5节中介绍的“Meta transactions for pool shares 元交易”功能。EIP-712定义了离线签名的规范，即digest的格式定义，用户签名的内容是其（owner）授权（approve）某个合约（spender）可以在截止时间（deadline）之前花掉一定数量（value）的代币（Pair流动性代币），应用（periphery合约）拿着签名的原始信息和签名后生成的v, r, s，可以调用Pair合约的permit方法获得授权，permit方法使用ecrecover还原出签名地址为代币所有人，验证通过则批准授权。

每个具体实现逻辑在 `UniswapV2Pair` 中。Pair合约主要实现了三个方法：mint（添加流动性）、burn（移除流动性）、swap（兑换）。

#### **UniswapV2Pair**

##### 1.mint
每个交易对创建流动性。

```s
function mint(address to) external lock returns (uint liquidity) {
    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
    uint balance0 = IERC20(token0).balanceOf(address(this));
    uint balance1 = IERC20(token1).balanceOf(address(this));
    uint amount0 = balance0.sub(_reserve0);
    uint amount1 = balance1.sub(_reserve1);

    bool feeOn = _mintFee(_reserve0, _reserve1);
    // gas savings, must be defined here since totalSupply can update in _mintFee
    uint _totalSupply = totalSupply; 
    if (_totalSupply == 0) {
        liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);
        // permanently lock the first MINIMUM_LIQUIDITY tokens
        _mint(address(0), MINIMUM_LIQUIDITY); 
    } else {
        liquidity = Math.min(
            amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1
        );
    }
    require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');
    _mint(to, liquidity);

    _update(balance0, balance1, _reserve0, _reserve1);
    if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
    emit Mint(msg.sender, amount0, amount1);
}
```

首先，getReserves()获取两种代币的缓存余额。在白皮书中提到，保存缓存余额是为了防止攻击者操控价格预言机。此处还用于计算协议手续费，并通过当前余额与缓存余额相减获得转账的代币数量。

因为在调用mint函数之前，在addLiquidity函数已经完成了转账，所以，从这个函数的角度，两种代币数量的计算方式如下：

```
uint balance0 = IERC20(token0).balanceOf(address(this));
uint balance1 = IERC20(token1).balanceOf(address(this));
uint amount0 = balance0.sub(_reserve0);
uint amount1 = balance1.sub(_reserve1);
```
_mintFee用于计算协议手续费：关于协议手续费的计算公式可以参考白皮书。

```
// if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)
function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {
    address feeTo = IUniswapV2Factory(factory).feeTo();
    feeOn = feeTo != address(0);
    uint _kLast = kLast; // gas savings
    if (feeOn) {
        if (_kLast != 0) {
            uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));
            uint rootKLast = Math.sqrt(_kLast);
            if (rootK > rootKLast) {
                uint numerator = totalSupply.mul(rootK.sub(rootKLast));
                uint denominator = rootK.mul(5).add(rootKLast);
                uint liquidity = numerator / denominator;
                if (liquidity > 0) _mint(feeTo, liquidity);
            }
        }
    } else if (_kLast != 0) {
        kLast = 0;
    }
}
```

当前的balance是当前的reserve加上注入的流动性的代币数量。

```s
// gas savings, must be defined here since totalSupply can update in _mintFee
uint _totalSupply = totalSupply; 
if (_totalSupply == 0) {
    liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);
    // permanently lock the first MINIMUM_LIQUIDITY tokens
    _mint(address(0), MINIMUM_LIQUIDITY); 
} else {
    liquidity = Math.min(
        amount0.mul(_totalSupply) / _reserve0, 
        amount1.mul(_totalSupply) / _reserve1
    );
}
require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');
_mint(to, liquidity);
```

流动性liquidity的计算方式在第一次提供流动性时和其他时候稍稍不同。mint方法中判断，如果是首次提供该交易对的流动性，则根据根号xy生成流动性代币，并销毁其中的MINIMUM_LIQUIDITY（即1000wei）；否则根据转入的代币价值与当前流动性价值比例铸造流动性代币。

第一次提供流动性的计算公式如下：

```
liquidity = sqrt(x0*y0) - min
```

其中min是10^3。也就是说，第一次提供流动性是有最小流动性要求的。

其他提供流动性的计算公式如下：按照注入的流动性和当前的reserve的占比一致。

```
liquidity = min((x0/reserve0*totalsupply), (y0/reserve1*totalsupply))
```


##### 2.burn

burn函数用在抽取流动性。burn逻辑和mint逻辑类似。

```s
function burn(address to) external lock returns (uint amount0, uint amount1) {
    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
    address _token0 = token0;                                // gas savings
    address _token1 = token1;                                // gas savings
    uint balance0 = IERC20(_token0).balanceOf(address(this));
    uint balance1 = IERC20(_token1).balanceOf(address(this));
    uint liquidity = balanceOf[address(this)];

    bool feeOn = _mintFee(_reserve0, _reserve1);

    // gas savings, must be defined here since totalSupply can update in _mintFee
    uint _totalSupply = totalSupply; 

    // using balances ensures pro-rata distribution
    amount0 = liquidity.mul(balance0) / _totalSupply; 

    // using balances ensures pro-rata distribution
    amount1 = liquidity.mul(balance1) / _totalSupply; 
    require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');
    _burn(address(this), liquidity);
    _safeTransfer(_token0, to, amount0);
    _safeTransfer(_token1, to, amount1);
    balance0 = IERC20(_token0).balanceOf(address(this));
    balance1 = IERC20(_token1).balanceOf(address(this));

    _update(balance0, balance1, _reserve0, _reserve1);
    if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
    emit Burn(msg.sender, amount0, amount1, to);
}
```

与mint类似，burn方法也会先计算协议手续费。参考白皮书，为了节省交易手续费，Uniswap v2只在mint/burn流动性时收取累计的协议手续费。移除流动性后，根据销毁的流动性代币占总量的比例获得对应的两种代币。

##### 3.swap

swap函数实现两种代币的兑换。

```s
function swap(
    uint amount0Out, 
    uint amount1Out, 
    address to, 
    bytes calldata data
    ) 
    external lock {
    require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');
    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
    require(amount0Out < _reserve0 && amount1Out < _reserve1, 
        'UniswapV2: INSUFFICIENT_LIQUIDITY');

    uint balance0;
    uint balance1;
    { // scope for _token{0,1}, avoids stack too deep errors
    address _token0 = token0;
    address _token1 = token1;
    require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');

    // optimistically transfer tokens
    if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); 
    // optimistically transfer tokens
    if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); 

    if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(
        msg.sender, amount0Out, amount1Out, data);
    balance0 = IERC20(_token0).balanceOf(address(this));
    balance1 = IERC20(_token1).balanceOf(address(this));
    }
    uint amount0In = balance0 > _reserve0 - amount0Out 
        ? balance0 - (_reserve0 - amount0Out) : 0;
    uint amount1In = balance1 > _reserve1 - amount1Out 
        ? balance1 - (_reserve1 - amount1Out) : 0;
    require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');
    { // scope for reserve{0,1}Adjusted, avoids stack too deep errors
    uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
    uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
    require(
        balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0)
                .mul(_reserve1).mul(1000**2), 
        'UniswapV2: K'
    );
    }

    _update(balance0, balance1, _reserve0, _reserve1);
    emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
}
```

一个交易池的swap操作支持两个方向的兑换，可以从TokenA换到TokenB，或者TokenB换到TokenA。

```
if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out);
if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out);
```
因为在`swapExactTokensForTokens`的`getAmountOut`函数已经确定兑换处的金额。所以，先直接转账。

在不做swap之前，balance应该和reserve相等的。通过`balance`和`reserve`的差值，可以反推出输入的代币数量：

```
uint amount0In = balance0 > _reserve0 - amount0Out 
    ? balance0 - (_reserve0 - amount0Out) : 0;
uint amount1In = balance1 > _reserve1 - amount1Out 
    ? balance1 - (_reserve1 - amount1Out) : 0;
```

确保反推的输入代币数量不小于零。

```
require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');
```

为了兼容闪电贷功能，以及不依赖特定代币的transfer方法，整个swap方法并没有类似amountIn的参数，而是通过比较当前余额与缓存余额的差值来得出转入的代币数量。

由于在swap方法最后会检查余额（扣掉手续费后）符合k常值函数约束（参考白皮书公式），因此合约可以先将用户希望获得的代币转出，如果用户之前并没有向合约转入用于交易的代币，则相当于借币（即闪电贷）；如果使用闪电贷，则需要在自定义的uniswapV2Call方法中将借出的代币归还。

在swap方法最后会使用缓存余额更新价格预言机所需的累计价格，最后更新缓存余额为当前余额。

```
// update reserves and, on the first call per block, price accumulators
function _update(
    uint balance0, 
    uint balance1, 
    uint112 _reserve0, 
    uint112 _reserve1) 
    private {
    require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');
    uint32 blockTimestamp = uint32(block.timestamp % 2**32);
    uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
    if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
        // * never overflows, and + overflow is desired
        price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0))
             * timeElapsed;
        price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1))
             * timeElapsed;
    }
    reserve0 = uint112(balance0);
    reserve1 = uint112(balance1);
    blockTimestampLast = blockTimestamp;
    emit Sync(reserve0, reserve1);
}
```

注意，其中区块时间戳和累计价格都是溢出安全的。（具体推导过程请参考白皮书）

### Periphery 逻辑

由于UniswapV2Router01在处理FeeOnTransferTokens时有bug，目前已不再使用。此处我们仅介绍最新版的UniswapV2Router02合约。

**UniswapV2Router02**

Router02封装了最常用的几个交易接口；为了满足原生ETH交易需求，大部分接口都支持ETH版本；同时，相比Router01，部分接口增加了FeeOnTrasnferTokens的支持。

![](https://i.imgur.com/vw84rOW.png)

我们将主要介绍ERC20版本的代码，因为ETH版本只是将ETH与WETH做转换，逻辑与ERC20一致。在介绍具体ERC20方法前，我们先介绍Library合约中的几个常用方法，以及它们的数学公式推导。

#### UniswapV2Library

**pairFor**:输入工厂地址和两个代币地址，计算这两个代币的交易对地址。

```
// calculates the CREATE2 address for a pair without making any external calls
function pairFor(
    address factory, 
    address tokenA, 
    address tokenB) 
    internal pure returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint(keccak256(abi.encodePacked(
            hex'ff',
            factory,
            keccak256(abi.encodePacked(token0, token1)),
            // init code hash
            hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' 
        ))));
}
```
上文提到，由于使用CREATE2操作码，交易对地址可以直接根据规范算出，而无需调用链上合约进行查询。

其中，新创建的pair合约的地址计算方法为：keccak256(0xff + this + salt + keccak256(mem[p…(p+n)))：

- this：工厂合约地址
- salt：keccak256(abi.encodePacked(token0, token1))
- keccak256(mem[p…(p+n))： 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f

由于每个交易对都使用UniswapV2Pair合约创建，因此init code hash都是一样的。我们可以在UniswapV2Factory写一个Solidty方法计算hash：

```
function initCodeHash() external pure returns (bytes32) {
    bytes memory bytecode = type(UniswapV2Pair).creationCode;
    bytes32 hash;
    assembly {
        hash := keccak256(add(bytecode, 32), mload(bytecode))
    }
    return hash;
}
```
**quote**: quote方法将数量为amountA的代币A，按照合约中两种代币余额比例，换算成另一个代币B。此时不考虑手续费，因为仅是计价单位的换算。

```
// given some amount of an asset and pair reserves, 
// returns an equivalent amount of the other asset
function quote(uint amountA, uint reserveA, uint reserveB) internal pure 
  returns (uint amountB) {
    require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');
    require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
    amountB = amountA.mul(reserveB) / reserveA;
}
```

**getAmountOut**: 该方法计算：输入一定数量（amountIn）代币A，根据池子中代币余额，能得到多少数量（amountOut）代币B。

```
// given an input amount of an asset and pair reserves, 
// returns the maximum output amount of the other asset
function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure 
  returns (uint amountOut) {
    require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');
    require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
    uint amountInWithFee = amountIn.mul(997);
    uint numerator = amountInWithFee.mul(reserveOut);
    uint denominator = reserveIn.mul(1000).add(amountInWithFee);
    amountOut = numerator / denominator;
}
```
为了推导该方法的数学公式，我们需要先回顾白皮书以及core合约中对于swap交换后两种代币的约束：

<span id="MJXc-Node-1" class="mjx-math" aria-hidden="true"><span id="MJXc-Node-2" class="mjx-mrow"><span id="MJXc-Node-3" class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.475em; padding-bottom: 0.58em;">(</span></span><span id="MJXc-Node-4" class="mjx-msubsup"><span class="mjx-base"><span id="MJXc-Node-5" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.213em; padding-bottom: 0.265em;">x</span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-6" class="mjx-mn" style=""><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.37em; padding-bottom: 0.318em;">1</span></span></span></span><span id="MJXc-Node-7" class="mjx-mo MJXc-space2"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.318em; padding-bottom: 0.423em;">−</span></span><span id="MJXc-Node-8" class="mjx-mn MJXc-space2"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.37em; padding-bottom: 0.37em;">0.003</span></span><span id="MJXc-Node-9" class="mjx-mo MJXc-space2"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.003em; padding-bottom: 0.318em;">⋅</span></span><span id="MJXc-Node-10" class="mjx-msubsup MJXc-space2"><span class="mjx-base"><span id="MJXc-Node-11" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.213em; padding-bottom: 0.265em;">x</span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-12" class="mjx-texatom" style=""><span id="MJXc-Node-13" class="mjx-mrow"><span id="MJXc-Node-14" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.423em; padding-bottom: 0.265em;">i</span></span><span id="MJXc-Node-15" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.213em; padding-bottom: 0.265em;">n</span></span></span></span></span></span><span id="MJXc-Node-16" class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.475em; padding-bottom: 0.58em;">)</span></span><span id="MJXc-Node-17" class="mjx-mo MJXc-space2"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.003em; padding-bottom: 0.318em;">⋅</span></span><span id="MJXc-Node-18" class="mjx-mo MJXc-space2"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.475em; padding-bottom: 0.58em;">(</span></span><span id="MJXc-Node-19" class="mjx-msubsup"><span class="mjx-base" style="margin-right: -0.006em;"><span id="MJXc-Node-20" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.213em; padding-bottom: 0.475em; padding-right: 0.006em;">y</span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-21" class="mjx-mn" style=""><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.37em; padding-bottom: 0.318em;">1</span></span></span></span><span id="MJXc-Node-22" class="mjx-mo MJXc-space2"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.318em; padding-bottom: 0.423em;">−</span></span><span id="MJXc-Node-23" class="mjx-mn MJXc-space2"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.37em; padding-bottom: 0.37em;">0.003</span></span><span id="MJXc-Node-24" class="mjx-mo MJXc-space2"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.003em; padding-bottom: 0.318em;">⋅</span></span><span id="MJXc-Node-25" class="mjx-msubsup MJXc-space2"><span class="mjx-base" style="margin-right: -0.006em;"><span id="MJXc-Node-26" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.213em; padding-bottom: 0.475em; padding-right: 0.006em;">y</span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-27" class="mjx-texatom" style=""><span id="MJXc-Node-28" class="mjx-mrow"><span id="MJXc-Node-29" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.423em; padding-bottom: 0.265em;">i</span></span><span id="MJXc-Node-30" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.213em; padding-bottom: 0.265em;">n</span></span></span></span></span></span><span id="MJXc-Node-31" class="mjx-mo"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.475em; padding-bottom: 0.58em;">)</span></span><span id="MJXc-Node-32" class="mjx-mo MJXc-space3"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.37em; padding-bottom: 0.475em;">≥</span></span><span id="MJXc-Node-33" class="mjx-msubsup MJXc-space3"><span class="mjx-base"><span id="MJXc-Node-34" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.213em; padding-bottom: 0.265em;">x</span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-35" class="mjx-mn" style=""><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.37em; padding-bottom: 0.37em;">0</span></span></span></span><span id="MJXc-Node-36" class="mjx-mo MJXc-space2"><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.003em; padding-bottom: 0.318em;">⋅</span></span><span id="MJXc-Node-37" class="mjx-msubsup MJXc-space2"><span class="mjx-base" style="margin-right: -0.006em;"><span id="MJXc-Node-38" class="mjx-mi"><span class="mjx-char MJXc-TeX-math-I" style="padding-top: 0.213em; padding-bottom: 0.475em; padding-right: 0.006em;">y</span></span></span><span class="mjx-sub" style="font-size: 70.7%; vertical-align: -0.212em; padding-right: 0.071em;"><span id="MJXc-Node-39" class="mjx-mn" style=""><span class="mjx-char MJXc-TeX-main-R" style="padding-top: 0.37em; padding-bottom: 0.37em;">0</span></span></span></span></span></span>

其中，x0, y0为交换前的两种代币余额，X1, Y1为交换后的两种代币余额，
Xin为输入的代币A数量，因为只提供代币A，因此Yin=0；Yout为需要计算的代币B数量。

**getAmountIn**:该方法计算当希望获得一定数量（amountOut）的代币B时，应该输入多少数量（amoutnIn）的代币A。

```
// given an output amount of an asset and pair reserves,
// returns a required input amount of the other asset
function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) 
  internal pure 
  returns (uint amountIn) {
    require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');
    require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
    uint numerator = reserveIn.mul(amountOut).mul(1000);
    uint denominator = reserveOut.sub(amountOut).mul(997);
    amountIn = (numerator / denominator).add(1);
}
```
getAmountOut是已知Xin，计算Yout；相对应地，getAmountIn则是已知 Yout，计算Xin。计算结果即为合约中代码所示，注意最后有一个add(1)，这是为了防止amountIn为小数的情况，加1可以保证输入的数（amountIn）不小于理论的最小值。

**getAmountsOut**该方法用于计算在使用多个交易对时，输入一定数量（amountIn）的第一种代币，最终能收到多少数量的最后一种代币（amounts）。amounts数组中的第一个元素表示amountIn，最后一个元素表示该目标代币对应的数量。该方法实际上是循环调用getAmountIn方法。

```
// performs chained getAmountOut calculations on any number of pairs
function getAmountsOut(
    address factory, uint amountIn, address[] memory path) 
    internal view 
    returns (uint[] memory amounts) {
    require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
    amounts = new uint[](path.length);
    amounts[0] = amountIn;
    for (uint i; i < path.length - 1; i++) {
        (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);
        amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);
    }
}
```

**getAmountsIn**:与getAmountsOut相对，getAmountsIn用于计算当希望收到一定数量（amountOut）的目标代币，应该分别输入多少数量的中间代币。计算方法也是循环调用getAmountIn。

```
// performs chained getAmountIn calculations on any number of pairs
function getAmountsIn(
    address factory, uint amountOut, address[] memory path) 
    internal view 
    returns (uint[] memory amounts) {
    require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
    amounts = new uint[](path.length);
    amounts[amounts.length - 1] = amountOut;
    for (uint i = path.length - 1; i > 0; i--) {
        (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);
        amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);
    }
}
```

#### ERC20-ERC20

##### addLiquidity 添加流动性

增加流动性，就是同时提供两种代币。因为代币有可能是ETH，针对不同情况有不同的接口。逻辑类似。

```
function addLiquidity(
    address tokenA,
    address tokenB,
    uint amountADesired,
    uint amountBDesired,
    uint amountAMin,
    uint amountBMin,
    address to,
    uint deadline
  ) external virtual override ensure(deadline) 
  returns (uint amountA, uint amountB, uint liquidity) {
    (amountA, amountB) = _addLiquidity(
        tokenA, tokenB, amountADesired, amountBDesired, 
        amountAMin, amountBMin);
    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
    TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);
    TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);
    liquidity = IUniswapV2Pair(pair).mint(to);
}
```

由于Router02是直接与用户交互的，因此接口设计需要从用户使用场景考虑。addLiquidity提供了8个参数：

- address tokenA：代币A
- address tokenB：代币B
- uint amountADesired：希望存入的代币A数量
- uint amountBDesired：希望存入的代币B数量
- uint amountAMin：最少存入的代币A数量
- uint amountBMin：最少存入的代币B数量
- address to：流动性代币接收地址
- uint deadline：请求失效时间

用户提交交易后，该交易被矿工打包的时间是不确定的，因此提交时的代币价格与交易打包时的价格可能不同，通过amountMin可以控制价格的浮动范围，防止被矿工或机器人套利；同样，deadline可以确保该交易在超过指定时间后将失效。

在core合约中提到，如果用户提供流动性时的代币价格与实际价格有差距，则只会按照较低的汇率得到流动性代币，多余的代币将贡献给整个池子。_addLiquidity可以帮助计算最佳汇率。如果是首次添加流动性，则会先创建交易对合约；否则根据当前池子余额计算应该注入的最佳代币数量。

```
// **** ADD LIQUIDITY ****
function _addLiquidity(
    address tokenA,
    address tokenB,
    uint amountADesired,
    uint amountBDesired,
    uint amountAMin,
    uint amountBMin
) internal virtual returns (uint amountA, uint amountB) {
    // create the pair if it doesn't exist yet
    if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {
        IUniswapV2Factory(factory).createPair(tokenA, tokenB);
    }
    (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);
    if (reserveA == 0 && reserveB == 0) {
        (amountA, amountB) = (amountADesired, amountBDesired);
    } else {
        uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);
        if (amountBOptimal <= amountBDesired) {
            require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');
            (amountA, amountB) = (amountADesired, amountBOptimal);
        } else {
            uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);
            assert(amountAOptimal <= amountADesired);
            require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');
            (amountA, amountB) = (amountAOptimal, amountBDesired);
        }
    }
}
```
最后调用core合约mint方法铸造流动性代币。

##### removeLiquidity 移除流动性

首先将流动性代币发送到pair合约，根据收到的流动性代币占全部代币比例，计算该流动性代表的两种代币数量。合约销毁流动性代币后，用户将收到对应比例的代币。如果低于用户设定的最低预期（amountAMin/amountBMin），则回滚交易。


```
// **** REMOVE LIQUIDITY ****
function removeLiquidity(
    address tokenA,
    address tokenB,
    uint liquidity,
    uint amountAMin,
    uint amountBMin,
    address to,
    uint deadline
) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {
    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);

    // send liquidity to pair
    IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); 
    (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);
    (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);
    (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);
    require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');
    require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');
}
```

liquidity是抽取的流动性的量。amountMin是抽取代币的最小的个数。to是抽取代币的目标地址。 deadline 是抽取的操作有时效性。超过了一定的deadline（区块高度），这次抽取操作看成无效。

先收回需要抽取的Token，并且销毁：

```
IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair
(uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);
```

##### removeLiquidityWithPermit 使用签名移除流动性

用户正常移除流动性时，需要两个操作：

- approve：授权Router合约花费自己的流动性代币
- removeLiquidity：调用Router合约移除流动性

除非第一次授权了最大限额的代币，否则每次移除流动性都需要两次交互，这意味着用户需要支付两次手续费。而使用removeLiquidityWithPermit方法，用户可以通过签名方式授权Router合约花费自己的代币，无需单独调用approve，只需要调用一次移除流动性方法即可完成操作，节省了gas费用。同时，由于离线签名不需要花费gas，因此可以每次签名仅授权一定额度的代币，提高安全性。

```
function removeLiquidityWithPermit(
    address tokenA,
    address tokenB,
    uint liquidity,
    uint amountAMin,
    uint amountBMin,
    address to,
    uint deadline,
    bool approveMax, uint8 v, bytes32 r, bytes32 s
) external virtual override returns (uint amountA, uint amountB) {
    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
    uint value = approveMax ? uint(-1) : liquidity;
    IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);
    (amountA, amountB) = removeLiquidity(
                            tokenA, tokenB, liquidity, 
                            amountAMin, amountBMin, to, deadline
                        );
}
```

##### swapExactTokensForTokens

交易时的两个常见场景：

- 使用指定数量的代币A（输入），尽可能兑换最多数量的代币B（输出）
- 获得指定数量的代币B（输出），尽可能使用最少数量的代币A（输入）

本方法实现第一个场景，即根据指定的输入代币，获得最多的输出代币。

```
function swapExactTokensForTokens(
    uint amountIn,
    uint amountOutMin,
    address[] calldata path,
    address to,
    uint deadline
) external virtual override ensure(deadline) returns (uint[] memory amounts) {
    amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);
    require(
        amounts[amounts.length - 1] >= amountOutMin, 
        'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
    TransferHelper.safeTransferFrom(
        path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
    );
    _swap(amounts, path, to);
}
```

首先使用Library合约中的getAmountsOut方法，根据兑换路径计算每一次交易的输出代币数量，确认最后一次交易得到的数量（amounts[amounts.length - 1]）不小于预期最少输出（amountOutMin）；将代币发送到第一个交易对地址，开始执行整个兑换交易。

假设用户希望使用WETH兑换DYDX，链下计算的最佳兑换路径为WETH → USDC → DYDX，则amountIn为WETH数量，amountOutMin为希望获得最少DYDX数量，path为[WETH address, USDC address, DYDX address]，amounts为[amountIn, USDC amount, DYDX amount]。在_swap执行交易的过程中，每次中间交易获得的中间代币将被发送到下一个交易对地址，以此类推，直到最后一个交易完成，_to地址将收到最后一次交易的输出代币。

```
// requires the initial amount to have already been sent to the first pair
function _swap(uint[] memory amounts, address[] memory path, address _to)
  internal virtual {
    for (uint i; i < path.length - 1; i++) {
        (address input, address output) = (path[i], path[i + 1]);
        (address token0,) = UniswapV2Library.sortTokens(input, output);
        uint amountOut = amounts[i + 1];
        (uint amount0Out, uint amount1Out) = input == token0 
            ? (uint(0), amountOut) : (amountOut, uint(0));
        address to = i < path.length - 2 
            ? UniswapV2Library.pairFor(factory, output, path[i + 2]) 
            : _to;
        IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(
            amount0Out, amount1Out, to, new bytes(0)
        );
    }
}
```
##### swapTokensForExactTokens

该方法实现交易的第二个场景，根据指定的输出代币，使用最少的输入代币完成兑换。

```
function swapTokensForExactTokens(
    uint amountOut,
    uint amountInMax,
    address[] calldata path,
    address to,
    uint deadline
) external virtual override ensure(deadline) returns (uint[] memory amounts) {
    amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
    require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
    TransferHelper.safeTransferFrom(
        path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
    );
    _swap(amounts, path, to);
}
```
与上面类似，这里先使用Library的getAmountsIn方法反向计算每一次兑换所需的最少输入代币数量，确认计算得出的（扣除手续费后）第一个代币所需的最少代币数不大于用户愿意提供的最大代币数（amountInMax）；将代币发送到第一个交易对地址，调用_swap开始执行整个兑换交易。

####  ERC20-ETH

##### ETH Support
由于core合约只支持ERC20代币交易，为了支持ETH交易，periphery合约需要将ETH与WETH做转换；并为大部分方法提供了ETH版本。兑换主要涉及两种操作：

- 地址转换：由于ETH没有合约地址，因此需要使用WETH合约的deposit和withdraw方法完成ETH与WETH的兑换
- 代币数量转换：ETH的代币需要通过msg.value获取，可根据该值计算对应的WETH数量，而后使用标准ERC20接口即可

##### FeeOnTransferTokens
由于某些代币会在转账（transfer）过程中收取手续费，转账数量与实际收到的数量有差异，因此无法直接通过计算得出中间兑换过程中所需的代币数量，此时应该通过balanceOf方法（而非transfer方法）判断实际收到的代币数量。Router02新增了对Inclusive Fee On Transfer Tokens的支持，更具体说明可以参考官方文档。


## Compound

- https://learnblockchain.cn/article/2593
- https://learnblockchain.cn/article/2618
- https://github.com/compound-finance/compound-protocol

![](https://img.learnblockchain.cn/attachments/2021/06/xHa8LB6H60c8a3164b575.png)

以上的合约关系图中，没包含治理合约。治理属于独立的板块，初期并不需要关心，所以可以先不管。

合约文件虽然有点多，但涉及核心业务的其实可以分为四个模块：

- **InterestRateModel**：
  - 利率模型的抽象合约，JumpRateModelV2、JumpRateModel、WhitePaperInterestRateModel 都是具体的利率模型实现。而 LegacyInterestRateModel 的代码和 InterestRateModel 相比，除了注释有些许不同，并没有其他区别。
- **Comptroller**：审计合约，封装了全局使用的数据，以及很多业务检验功能。
  - 其入口合约为 **Unitroller**，也是一个代理合约。
- **PriceOracle**：价格预言机合约，用来获取资产价格的。
- **CToken**：cToken 代币的核心逻辑实现都在该合约中，属于抽象基类合约，没有构造函数，且定义了 3 个抽象函数
  - CEther 是 cETH 代币的入口合约，直接继承自 CToken。
  - ERC20 的 cToken 入口则是 CErc20Delegator ，这是一个代理合约，而实际实现合约为 CErc20Delegate 或 CCompLikeDelegate、CDaiDelegate 等。

下面，对每个模块再分别深入讲解。


### InterestRateModel

我们来看看 InterestRateModel 合约的代码：

```
pragma solidity ^0.5.16;

/**
  * @title Compound's InterestRateModel Interface
  * @author Compound
  */
contract InterestRateModel {
    /// @notice Indicator that this is an InterestRateModel contract (for inspection)
    bool public constant isInterestRateModel = true;

    function getBorrowRate(uint cash, uint borrows, uint reserves) 
      external view returns (uint);

    function getSupplyRate(
        uint cash, 
        uint borrows, 
        uint reserves, 
        uint reserveFactorMantissa) 
      external view returns (uint);

}
```

其实就是定义了利率模型的接口，但因为声明了一个常量 _isInterestRateModel_ 用来标明这是一个利率模型合约，所以没用 **interface** 声明，而用 **contract**，定义成抽象合约。Compound 的很多接口都是采用这种方式定义的。

该接口只定义了两个函数，_getBorrowRate()_ 和 _getSupplyRate()_，分别用来获取当前的借款利率和存款利率。但这两个利率不是**年化率**，也不是**日利率**，而是**区块利率**，即按每个区块计算的利率。

### 直线型

而具体的利率模型实现有好几个，**WhitePaperInterestRateModel** 是最简单的一种实现，**直线型**的利率模型。所谓的直线，其实是借款利率的，其计算公式为：

```
y = k*x + b
```

y 即 y 轴的值，即借款利率值，x 即 x 轴的值，表示资金使用率，k 为斜率，b 则是 x 为 0 时的起点值。

理解了这条公式之后，我们再来看代码就会很好理解那些值的含义了。先来看看构造函数：

```
constructor(uint baseRatePerYear, uint multiplierPerYear) public {
    baseRatePerBlock = baseRatePerYear.div(blocksPerYear);
    multiplierPerBlock = multiplierPerYear.div(blocksPerYear);

    emit NewInterestParams(baseRatePerBlock, multiplierPerBlock);
}

```

构造函数有两个入参：

*   **baseRatePerYear**：基准年利率，其实就是公式中的 b 值
*   **multiplierPerYear**：其实就是斜率 k 值

构造函数的实现中，_blocksPerYear_ 是一个常量值，表示一年内的区块数 2102400，是按照每 15 秒出一个区块计算得出的。将两个入参分别除以 _blocksPerYear_，就分别得到了区块级别的基准利率和区块斜率。

那公式中的 b 值和 k 值都初始化好了，x 值即资金使用率则是动态计算的，计算公式为：

```
资金使用率 = 总借款 / (资金池余额 + 总借款 - 储备金)
utilizationRate = borrows / (cash + borrows - reserves)
```

其代码实现如下：

```
function utilizationRate(uint cash, uint borrows, uint reserves) 
  public pure returns (uint) {
    // Utilization rate is 0 when there are no borrows
    if (borrows == 0) {
      return 0;
    }

    return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
}
```

其中，mul(1e18) 是为了将结果值扩展为对应的精度整数。

那么，借款利率的实现也很容易理解了，代码如下：

```
function getBorrowRate(uint cash, uint borrows, uint reserves)
  public view returns (uint) {
    uint ur = utilizationRate(cash, borrows, reserves);
    return ur.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
}
```

其中，div(1e18) 则是因为 ur 和 multiplierPerBlock 本身都已经扩为高精度整数了，相乘之后精度变成 36 了，所以再除以 1e18 就可以把精度降回 18。

最后，存款利率又是如何计算的呢？请看代码：

```
function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) 
  public view returns (uint) {
    uint oneMinusReserveFactor = uint(1e18).sub(reserveFactorMantissa);
    uint borrowRate = getBorrowRate(cash, borrows, reserves);
    uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
    return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
}
```

整理一下就可得到计算公式为：

```
存款利率 = 资金使用率 * 借款利率 *（1 - 储备金率）
supplyRate = utilizationRate * borrowRate * (1 - reserveFactor)
```

至此，直线型的利率模型，合约内容就这么多了，还是非常容易理解的。

下面，我们来剖析拐点型的利率模型。

### 拐点型

拐点型主要有过两个版本的实现，**JumpRateModel** 和 **JumpRateModelV2**，目前，曾经使用 _JumpRateModel_ 的都已经升级为 _JumpRateModelV2_，所以我们就直接研究 JumpRateModelV2 即可。

回想下拐点型的图形，基本特征就是在拐点前的借款利率是一条直线，拐点后则是另一条斜率高得多的直线。

资金使用率没超过拐点值时，利率公式和直线型的一样：`y = k*x + b`
``
而超过拐点之后，则利率公式将变成：`y = k2*(x - p) + (k*p + b)`

其中，k2 表示拐点后的直线的斜率，p 则表示拐点的 x 轴的值。因此，需要初始化的参数有 4 个：**b、k、k2、p**，分别对应了构造函数中的几个入参：**baseRatePerYear、multiplierPerYear、jumpMultiplierPerYear、kink**。而几个 PerYear 入参对应的就有几个 PerBlock 变量，和前面一样，就不重复说明了。

那理解了上面的计算公式，我们来看看获取借款利率的代码实现：

```
function getBorrowRateInternal(uint cash, uint borrows, uint reserves) 
  internal view returns (uint) {
    uint util = utilizationRate(cash, borrows, reserves);

    if (util <= kink) {
      	return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
    } else {
        uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        uint excessUtil = util.sub(kink);
        return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
    }
}
```

如果这都还不理解代码实现，请结合公式多看几遍。

而存款利率的计算公式则和直线型的一样，没有变化。因为存款利率是随着借款利率而变的，所以斜率其实也跟随着借款利率而变化。

### CToken

CToken 合约管理着 cToken 代币，也管理着借贷的资金池，所以 CToken 的核心地位毋庸置疑。

CToken 合约只是个基类合约，没有构造函数，且还声明了几个抽象函数，由上层合约来实现。上层合约主要分两类，一类是用来处理 ETH 的 **CEther** 合约，该合约也是用户交互的入口合约；一类是用来处理 ERC20 的 **CErc20** 合约。在早期版本中，CErc20 也是用户交互的入口合约，但后来做了调整，CErc20 移除了构造函数，改为了初始化函数，增加了 CErc20Delegate 作为其上层合约，而且还增加了 CErc20Delegator 来代理 CToken，作为 cToken 的入口合约。

简而言之，**ETH** 的 cToken 交互入口是 **CEther** 合约，仅此一份；而 **ERC20** 的 cToken 交互入口则是 **CErc20Delegator** 合约，每种 ERC20 资产都各有一份入口合约。

代理合约很重要，可实现数据与逻辑的分离，是保证 CToken 合约可升级的基础。使用代理合约后，用户对目标合约的所有调用都通过代理合约，代理合约会将调用请求重定向到目标合约中。请看下图：

![image20210611172724678.png](https://img.learnblockchain.cn/attachments/2021/06/DszckFWv60c8a34207d76.png)

CErc20Delegator 就对应于图中的 Proxy Contract，而 CErc20Delegate 则对应于 Logic Contract。这种代理模式的基本原理主要是用到了 delegatecall 函数，若想深入理解可实现合约升级的代理模式，可查看此文章：[https://blog.openzeppelin.com/proxy-patterns/](https://blog.openzeppelin.com/proxy-patterns/)。

每个 cToken 合约初始化时至少需要指定几个重要参数：

*   **underlying**：标的资产合约，每种 cToken 都对应于每种标的资产
*   **comptroller**：审计合约，所有 cToken 都会使用同一个审计合约
*   **interestRateModel**：利率模型合约，每种 cToken 都有各自的利率模型合约

其中，comptroller 和 interestRateModel 是可以更换的，当两者存在升级版本时，就可以分别调用 **\_setComptroller(newComptroller)** 和 **\_setInterestRateModel(newInterestRateModel)** 更换为升级后的合约。

存取借款等核心业务的入口函数则主要有以下几个：

*   **mint**：存款，之所以叫 mint，是因为该操作会新增 cToken 数量，即 totalSupply 增加了，就等于挖矿了 cToken。该操作会将用户的标的资产转入 cToken 合约中（数据会存储在代理合约中），并根据最新的兑换率将对应的 cToken 代币转到用户钱包地址。
*   **redeem**：赎回存款，即用 cToken 换回标的资产，会根据最新的兑换率计算能换回多少标的资产。
*   **redeemUnderlying**：同样是赎回存款的函数，与上一个函数不同的是，该函数指定的是标的资产的数量，会根据兑换率算出需要扣减多少 cToken。
*   **borrow**：借款，会根据用户的抵押物来计算可借额度，借款成功则将所借资产从资金池中直接转到用户钱包地址。
*   **repayBorrow**：还款，当指定还款金额为 -1 时，则表示全额还款，包括所有利息，否则，则会存在利息没还尽的可能，因为每过一个区块就会产生新的利息。
*   **repayBorrowBehalf**：代还款，即支付人帮借款人还款。
*   **liquidateBorrow**：清算，任何人都可以调用此函数来担任清算人，直接借款人、还款金额和清算的 cToken 资产，清算时，清算人帮借款人代还款，并得到借款人所抵押的等值+清算奖励的 cToken 资产。

以上，每一步操作发生时，都会调用 **accrueInterest()** 函数计算新的利息。该函数的实现逻辑主要如下：

1.  获取当前区块 crrentBlockNumber 和最近一次计算的区块 accrualBlockNumberPrior，如果两个区块相等，表示当前区块已经计算过利息，无需再计算，直接返回。
2.  获取保存的 cash（资金池余额）、totalBorrows（总借款）、totalReserves（总储备金）、borrowIndex（借款指数）。
3.  调用 interestRateModel.getBorrowRate() 得到借款利率 borrowRate。
4.  如果 borrowRate 超过最大的借款利率，则错误退出，否则进入下一步。
5.  计算当前区块和 accrualBlockNumberPrior 之间的区块数 blockDelta，该区块数即是还未计算利息的区块区间。
6.  根据以下公式计算出新累积的利息和一些新值：
    *   simpleInterestFactor = borrowRate \* blockDelta，区块区间内的单位利息
    *   interestAccumulated = simpleInterestFactor \* totalBorrows，表示总借款在该区块区间内产生的总利息
    *   totalBorrowsNew = interestAccumulated + totalBorrows，将总利息累加到总借款中
    *   totalReservesNew = interestAccumulated \* reserveFactor + totalReserves，根据储备金率将部分利息累加到储备金中
    *   borrowIndexNew = simpleInterestFactor \* borrowIndex + borrowIndex，累加借款指数
7.  更新以下值：
    *   accrualBlockNumber = currentBlockNumber
    *   borrowIndex = borrowIndexNew
    *   totalBorrows = totalBorrowsNew
    *   totalReserves = totalReservesNew
8.  发射 AccrueInterest() 事件。

另外，存取借还时，还会调用 comptroller 对应的 XXXAllowed() 函数进行审计。比如，mint() 函数对应调用 mintAllowed() 函数。

### Comptroller

**Comptroller** 是一个审计合约，顾名思义，主要职责就是对存取借款等核心业务进行审查和校验，查看 **ComptrollerInterface** 定义了哪些函数就可以看出来，审计函数主要有：

*   **mintAllowed()**：是否允许存款
*   **redeemAllowed()**：是否允许取款
*   **borrowAllow()**：是否允许借款
*   **repayBorrowAllowed()**：是否允许还款
*   **liquidateBorrowAllowed()**：是否允许清算
*   **seizeAllowed()**：是否允许清算抵押物
*   **transferAllowed()**：是否允许转账

另外，对应于以上每个函数，接口中还分别定义了对应的 **Verify()** 函数，比如 **mintVerify()、redeemVerify()** 等，但这些 Verify() 函数在 Compound 目前的实现中并没做任何实质性的操作。

借贷市场上要支持哪些资产的存借，也是在 Comptroller 设置的，通过调用 **\_supportMarket(CToken)** 函数进行设置。支持的市场会存储到以下两个数据结构中：

```
/**
 * @notice Official mapping of cTokens -> Market metadata
 * @dev Used e.g. to determine if a market is supported
 */
mapping(address => Market) public markets;

/// @notice A list of all markets
CToken[] public allMarkets;
```

用户还可以选择对存入的资产开启或关闭作为抵押品，对应的函数则是：

*   **enterMarkets(address\[\] memory cTokens)**
*   **exitMarket(address cTokenAddress)**

enterMarkets 可以将指定的多个 cToken 作为抵押品，对应地就可增加用户的可借额度。exitMarket 则可以将指定 cToken 从抵押品列表中移除，但是，如果用户存在借款时，exitMarket 的资产价值不能超过借款价值。用户的抵押品列表会存储在 accountAssets 中：

`mapping(address => CToken[]) public accountAssets;`

其中，address 为每个用户的钱包地址。

而下面这个函数则可以获得用户的资产状况：

```
/**
 * @notice Determine the current account liquidity wrt collateral requirements
 * @return (possible error code (semi-opaque),
 *   account liquidity in excess of collateral requirements,
 *   account shortfall below collateral requirements)
 */
function getAccountLiquidity(address account) 
  public view 
  returns (uint, uint, uint) {
  	(Error err, uint liquidity, uint shortfall) = 
        getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);

  	return (uint(err), liquidity, shortfall);
}
```

其中，返回的 liquidity 表示剩余的可借额度，它是用户的抵押物总价值（乘以**抵押因子**后的价值）sumCollateral 和总债务 sumBorrowPlusEffects 的差额。当这个差额为正数时，则 **liquidity = sumCollateral - sumBorrowPlusEffects**，此时 shortfall 为 0；而差额为负数时，则 liquidity 为 0，**shortfall = sumBorrowPlusEffects - sumCollateral**，此时表示用户债务已经超过了清算门槛，已经可以被清算。

每个市场的**抵押因子**也是在 Comptroller 中设置的，通过 **\_setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa)** 函数进行设置。

而且，计算用户资产状况时，需要用到价格预言机 PriceOracle，Comptroller 也提供了函数用来设置所使用的价格预言机：

```
function _setPriceOracle(PriceOracle newOracle) public returns (uint) {
    // Check caller is admin
    if (msg.sender != admin) {
    		return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);
    }

    // Track the old oracle for the comptroller
    PriceOracle oldOracle = oracle;

    // Set comptroller's oracle to newOracle
    oracle = newOracle;

    // Emit NewPriceOracle(oldOracle, newOracle)
    emit NewPriceOracle(oldOracle, newOracle);

    return uint(Error.NO_ERROR);
}
```

### PriceOracle

价格预言机是 DeFi 借贷产品中必不可少的组成部分，前面提到的获取用户资产状态的函数 getAccountLiquidity() 中，计算用户的抵押物价值和债务价值都需要通过价格预言机读取到各种代币的市场价格。

接口层面，PriceOracle 定义了最小化接口，很简单，请看代码：

```
contract PriceOracle {
    bool public constant isPriceOracle = true;

    function getUnderlyingPrice(CToken cToken) external view returns (uint);
}
```

就只有一个常量和一个函数，常量 isPriceOracle 只是为了方便检验这是一个 PriceOracle，getUnderlyingPrice() 则会根据 cToken 获取对应的标的资产的价格。

而具体的实现，Compound 使用的是自己的一套价格预言机 [Open Price Feed](https://compound.finance/docs/prices)。其机制中有三种角色：**Reporter、Poster、View**。Reporter 主要是由 CEX、DEX 来承担，主要职责是对一些交易对的币价用自己的私钥进行签名并公开出去，Poster 则负责将 Reporter 已签名的数据发布到链上，View 才是 DApp 实际应用的合约，可以由多个 Reporter 任意组合而成。

Compound 使用的实现类为 **UniswapAnchoredView**，只使用了一个 Reporter 的签名数据，Coinbase 的价格数据，而任何人都可以充当 Poster 调用该合约的 postPrice() 函数将 Reporter 的价格数据发布到链上。不过有一点需要注意，Coinbase 所签名的价格数据并不是很实时的价格，根据 Compound 官方文档所说的，每隔几分钟才签发一次数据的，所以价格也是滞后几分钟的。postPrices() 函数的声明如下：

```
function postPrices(
    bytes[] calldata messages, 
    bytes[] calldata signatures, 
    string[] calldata symbols
)
```

UniswapAnchoredView 还提供了一个通用的获取 USD 价格的函数：

```
function price(string memory symbol) external view returns (uint)
```

最后，自然也实现了 PriceOracle 接口所定义的函数：

```
function getUnderlyingPrice(address cToken) external view returns (uint)
```

不过，Compound 的这套预言机，因为数据源只有 Coinbase 一家，所以存在被攻击的风险，去年 11 月底就因为攻击者短时操纵了 Coinbase 上 DAI/USD 的价格，使其一度暴涨超 30%，导致 Compound 上的抵押资产大规模被清算。所以，价格预言机的数据源最好是集成多家，采用加权平均法计算得出。

### 总结

Compound 的合约虽然看起来比较多，但核心业务的其实就那么几个，这几个理解透了，也就搞懂 Compound 的很多业务逻辑细节了。另外，Compound 的很多设计都挺值得学习的，比如它所使用的代理模式，比 OpenZeppelin 所提供的实现简单得多。

## 其他

https://u.naturaldao.io/be/

## Uniswap V3

- https://hackmd.io/@adshao/SJT0-bVz9
- https://hackmd.io/@adshao/HJ2oeEt79
- https://liaoph.com/uniswap-v3-1/
- https://zhuanlan.zhihu.com/p/506825777

## 练习题

- 一个Uniswap v2交易对，初始提供100ETH和10,000 token的流动性，获得1000枚LP。现在有一个用户手里有10ETH，如果他希望全部用来做市，应该将多少eth置换为token，以便和手里剩余的eth能正好组成LP？
  - https://hackmd.io/@adshao/SywHLDdq9

